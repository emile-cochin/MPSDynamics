<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · MPSDynamics.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="MPSDynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">MPSDynamics.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../user-guide/">User Guide</a></li><li><a class="tocitem" href="../nutshell/">In a nutshell: MPSDynamics.jl for open quantum systems</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/sbm/">The Spin-Boson Model</a></li><li><a class="tocitem" href="../examples/puredephasing/">Pure-Dephasing</a></li><li><a class="tocitem" href="../examples/timedep/">Time-dependent Hamiltonian</a></li><li><a class="tocitem" href="../examples/anderson-model/">The Anderson Impurity Model</a></li><li><a class="tocitem" href="../examples/bath-observables/">Inspecting the bath by undoing the chain mapping</a></li><li><a class="tocitem" href="../examples/protontransfer/">Proton Transfer Model</a></li></ul></li><li><a class="tocitem" href="../theory/">Theoretical Background</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Matrix-Product-State-(MPS)"><span>Matrix Product State (MPS)</span></a></li><li><a class="tocitem" href="#Tree-Tensor-Network-(TTN)"><span>Tree Tensor Network (TTN)</span></a></li><li><a class="tocitem" href="#Measure-and-Obervables"><span>Measure and Obervables</span></a></li><li><a class="tocitem" href="#Models-and-Hamiltonians-(MPO)"><span>Models and Hamiltonians (MPO)</span></a></li><li><a class="tocitem" href="#Chain-Mapping"><span>Chain-Mapping</span></a></li><li><a class="tocitem" href="#Dynamics-propagation-function"><span>Dynamics propagation function</span></a></li><li><a class="tocitem" href="#Advanced"><span>Advanced</span></a></li></ul></li><li><a class="tocitem" href="../dev/">Developers</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/shareloqs/MPSDynamics/blob/master/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="List-of-all-methods"><a class="docs-heading-anchor" href="#List-of-all-methods">List of all methods</a><a id="List-of-all-methods-1"></a><a class="docs-heading-anchor-permalink" href="#List-of-all-methods" title="Permalink"></a></h1><h2 id="Matrix-Product-State-(MPS)"><a class="docs-heading-anchor" href="#Matrix-Product-State-(MPS)">Matrix Product State (MPS)</a><a id="Matrix-Product-State-(MPS)-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Product-State-(MPS)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Int64}" href="#MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Int64}"><code>MPSDynamics.apply1siteoperator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply1siteoperator!(A, O, sites::Int)</code></pre><p>Apply an operator O on the MPS A. O is acting on only one site ::Int. The resulting MPS A is the MPS modified by the operator O.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L534-L539">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Vector{Int64}}" href="#MPSDynamics.apply1siteoperator!-Tuple{Any, Any, Vector{Int64}}"><code>MPSDynamics.apply1siteoperator!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">apply1siteoperator!(A, O, sites::Vector{Int})</code></pre><p>Apply an operator O on the MPS A. O is acting on several sites ::Vector{Int}. The resulting MPS A is the MPS modified by the operator O.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L521-L526">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.applympo!-Tuple{Any, Any}" href="#MPSDynamics.applympo!-Tuple{Any, Any}"><code>MPSDynamics.applympo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">applympo!(A, H)</code></pre><p>Apply an MPO H on the MPS A. H must have the same number of site than A. The resulting MPS A is the MPS modified by the MPO H.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L542-L547">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}" href="#MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, site::Int, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations on <code>site</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L221-L228">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainmps-Tuple{Int64, Vector{Int64}, Int64}" href="#MPSDynamics.chainmps-Tuple{Int64, Vector{Int64}, Int64}"><code>MPSDynamics.chainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainmps(N::Int, sites::Vector{Int}, numex::Int)</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal super-position over <code>sites</code></p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L248-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.displacedchainmps-Tuple{Vector{Any}, Int64, Int64, Any}" href="#MPSDynamics.displacedchainmps-Tuple{Vector{Any}, Int64, Int64, Any}"><code>MPSDynamics.displacedchainmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">displacedchainmps(A::Vector{Any}, N::Int, Nm::Int, γ::Any)</code></pre><p>Given a MPS A, return a MPS B where the <code>Nm</code>-long chain is displaced by <code>γ</code> without displacing the <code>N</code>-long system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L724-L728">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.electron2kmps" href="#MPSDynamics.electron2kmps"><code>MPSDynamics.electron2kmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">electronkmps(N::Int, k::Vector{Int}, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with 2 electrons in k-states <code>k1</code> and <code>k2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L382-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.electronkmps" href="#MPSDynamics.electronkmps"><code>MPSDynamics.electronkmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">electronkmps(N::Int, k::Int, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS for an electron with momentum <code>k</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L346-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.elementmpo-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.elementmpo-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.elementmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmpo(M, el...)</code></pre><p>Return the element of the MPO <code>M</code> for the set of physical states <code>el...</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L506-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.elementmps-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.elementmps-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.elementmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementmps(A, el...)</code></pre><p>Return the element of the MPS <code>A</code> for the set of physical states <code>el...</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; A = chainmps(6, [2,4], 1);

julia&gt; elementmps(A, 1, 2, 1, 1, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 1, 1, 2, 1, 1)
0.7071067811865475

julia&gt; elementmps(A, 1, 2, 1, 2, 1, 1)
0.0

julia&gt; elementmps(A, 1, 1, 1, 1, 1, 1)
0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L473-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.entanglemententropy-Tuple{Any}" href="#MPSDynamics.entanglemententropy-Tuple{Any}"><code>MPSDynamics.entanglemententropy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">entanglemententropy(A)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L422-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of an equal superposition of modes <code>k</code> of a bosonic tight-binding chain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.modemps" href="#MPSDynamics.modemps"><code>MPSDynamics.modemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])</code></pre><p>Generate an MPS with <code>numex</code> excitations of mode <code>k</code> of a bosonic tight-binding chain. </p><p><code>chainparams</code> takes the form <code>[e::Vector, t::Vector]</code> where <code>e</code> are the on-site energies and <code>t</code> are the hoppping parameters.</p><p>The returned MPS will have bond-dimensions and physical dimensions <code>numex+1</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L276-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsembed!-Tuple{Vector, Int64}" href="#MPSDynamics.mpsembed!-Tuple{Vector, Int64}"><code>MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsembed!(A::Vector, Dmax::Int)</code></pre><p>Embed MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L695-L699">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsleftnorm!" href="#MPSDynamics.mpsleftnorm!"><code>MPSDynamics.mpsleftnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsleftnorm!(A::Vector, jq::Int=length(A))</code></pre><p>Left orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{Vector, Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{Vector, Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::Vector, OC::Int)</code></pre><p>Put MPS <code>A</code> into mixed canonical form with orthogonality centre on site <code>OC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!" href="#MPSDynamics.mpsrightnorm!"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::Vector, jq::Int=1)</code></pre><p>Right orthoganalise MPS <code>A</code> up to site <code>jq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.multiply-Tuple{Vector, Vector}" href="#MPSDynamics.multiply-Tuple{Vector, Vector}"><code>MPSDynamics.multiply</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multiply(M1::Vector, M2::Vector)</code></pre><p>Calculates M1*M2 where M1 and M2 are MPOs</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L676-L681">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{Vector}" href="#MPSDynamics.normmps-Tuple{Vector}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(A::Vector; mpsorthog=:None)</code></pre><p>Calculate norm of MPS <code>A</code>.</p><p>Setting <code>mpsorthog</code>=<code>:Right</code>/<code>:Left</code> will calculate the norm assuming right/left canonical form. Setting <code>mpsorthog=OC::Int</code> will cause the norm to be calculated assuming the orthoganility center is on site <code>OC</code>. If mpsorthog is <code>:None</code> the norm will be calculated as an MPS-MPS product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L21-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.orthcentersmps-Tuple{Vector}" href="#MPSDynamics.orthcentersmps-Tuple{Vector}"><code>MPSDynamics.orthcentersmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">orthcentersmps(A)</code></pre><p>Compute the orthoganality centres of MPS <code>A</code>.</p><p>Return value is a list in which each element is the corresponding site tensor of <code>A</code> with the orthoganility centre on that site. Assumes <code>A</code> is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.physdims-Tuple{Vector}" href="#MPSDynamics.physdims-Tuple{Vector}"><code>MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">physdims(M)</code></pre><p>Return the physical dimensions of an MPS or MPO <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L617-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p>The argument <code>mpsorthog</code> can be used to set the gauge of the resulting MPS.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ψ = unitcol(1,2); d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1

julia&gt; cpars = chaincoeffs_ohmic(N, α, s)

julia&gt; H = spinbosonmpo(ω0, Δ, d, N, cpars)

julia&gt; A = productstatemps(physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # MPS representation of |ψ&gt;|Vacuum&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L134-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)</code></pre><p>Return an <code>N</code>-site MPS with all local Hilbert space dimensions given by <code>d</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(N::Int, d::Int, Dmax::Int, T=Float64)</code></pre><p>Construct a random, <code>N</code>-site, right-normalised MPS with all local Hilbert space dimensions given by <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Int64}, Tuple{Tuple{Vararg{Int64, N}}, Int64, Type{&lt;:Number}}} where N" href="#MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Int64}, Tuple{Tuple{Vararg{Int64, N}}, Int64, Type{&lt;:Number}}} where N"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randmps(physdims::Dims{N}, Dmax::Int, T::Type{&lt;:Number} = Float64) where {N}</code></pre><p>Construct a random, right-normalised MPS with local Hilbert space dimensions given by <code>physdims</code> and max bond-dimension given by <code>Dmax</code>. </p><p><code>T</code> specifies the element type, eg. use <code>T=ComplexF64</code> for a complex valued MPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.reversempo!-Tuple{Any}" href="#MPSDynamics.reversempo!-Tuple{Any}"><code>MPSDynamics.reversempo!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reversempo!(M)</code></pre><p>Reverse the left and right dimensions of the MPO M. The resulting MPO M is the reversed MPO.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L588-L593">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.reversempo-Tuple{Any}" href="#MPSDynamics.reversempo-Tuple{Any}"><code>MPSDynamics.reversempo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reversempo(M)</code></pre><p>Reverse the left and right dimensions of the MPO M.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L602-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.reversemps!-Tuple{Any}" href="#MPSDynamics.reversemps!-Tuple{Any}"><code>MPSDynamics.reversemps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reversemps!(A)</code></pre><p>Reverse the left and right dimensions of the MPS A. The resulting MPS A is the reversed MPS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L559-L564">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.reversemps-Tuple{Any}" href="#MPSDynamics.reversemps-Tuple{Any}"><code>MPSDynamics.reversemps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">reversemps(A)</code></pre><p>Reverse the left and right bond-dimensions of the MPS A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L573-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.svdmps-Tuple{Any}" href="#MPSDynamics.svdmps-Tuple{Any}"><code>MPSDynamics.svdmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svdmps(A)</code></pre><p>For a right normalised mps <code>A</code> compute the full svd spectrum for a bipartition at every bond.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/mpsBasics.jl#L451-L455">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reshape-Tuple{Number, Vararg{Any}}" href="#Base.reshape-Tuple{Number, Vararg{Any}}"><code>Base.reshape</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.reshape(x::Number, dims...)</code></pre><p>Reshape any matrix with dimensions &quot;dims&quot;</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; A = rand(2,3,2)

julia&gt; B = reshape(A,4,3)

julia&gt; size(B) == (4,3) 
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/reshape.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.svdtrunc-Tuple{Any}" href="#MPSDynamics.svdtrunc-Tuple{Any}"><code>MPSDynamics.svdtrunc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)</code></pre><p>Perform a truncated SVD, with maximum number of singular values to keep equal to <code>truncdim</code> or truncating any singular values smaller than <code>truncerr</code>. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ≈ U * S * Vt</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/tensorOps.jl#L594-L601">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.MPOtoVector-Tuple{ITensors.MPO}" href="#MPSDynamics.MPOtoVector-Tuple{ITensors.MPO}"><code>MPSDynamics.MPOtoVector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">MPOtoVector(mpo::MPO)</code></pre><p>Convert an ITensors chain MPO into a form compatible with MPSDynamics</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L505-L510">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chainprop-Tuple{Any, Any}" href="#MPSDynamics.chainprop-Tuple{Any, Any}"><code>MPSDynamics.chainprop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chainprop(t, cparams...)</code></pre><p>Propagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L341-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.cosineh-Tuple{Any, Any}" href="#MPSDynamics.cosineh-Tuple{Any, Any}"><code>MPSDynamics.cosineh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cosineh(omega, bet)

Calculates the hyperbolic cosine function function based on the input parameters, 
for the Bogoliubov transformation necessary for the thermofield transformation.

# Arguments
- `omega::Float64`: The frequency parameter.
- `bet::Float64`: The beta parameter.

# Returns
- `Float64`: The result of the modified cosine function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L228-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.disp-Tuple{Any, Any, Any}" href="#MPSDynamics.disp-Tuple{Any, Any, Any}"><code>MPSDynamics.disp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function disp(d,ωvib,m)</code></pre><p>Displacement operator  <span>$X = \frac{\sqrt{2}}{2\sqrt{m \omega_{vib}}}(a + a^{\dagger})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L16-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.disp-Tuple{Any}" href="#MPSDynamics.disp-Tuple{Any}"><code>MPSDynamics.disp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">function disp(d)</code></pre><p>Mass and frequency-weighted displacement operator  <span>$X = \frac{1}{2}(a + a^{\dagger})$</span></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L6-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.dynamap-NTuple{4, Any}" href="#MPSDynamics.dynamap-NTuple{4, Any}"><code>MPSDynamics.dynamap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dynamap(ps1,ps2,ps3,ps4)</code></pre><p>Calculate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L405-L410">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.findchainlength-Tuple{Any, Any}" href="#MPSDynamics.findchainlength-Tuple{Any, Any}"><code>MPSDynamics.findchainlength</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchainlength(T, cparams...; eps=10^-6)</code></pre><p>Estimate length of chain required for a particular set of chain parameters by calculating how long an excitation on the first site takes to reach the end. The chain length is given as the length required for the excitation to have just reached the last site after time T. The initial number of sites in cparams has to be larger than the findchainlength result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L311-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measurecorrs-Tuple{Any, Vector, Vector}" href="#MPSDynamics.measurecorrs-Tuple{Any, Vector, Vector}"><code>MPSDynamics.measurecorrs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measurecorrs(oper, , e::Vector, t::Vector)

### Parameters

`oper``: Square matrix (Matrix{Float64}) representing the operator to be transformed.
`e``: Vector (Vector{Float64}) of diagonal (on-site energy) chain coefficients.
`t`: Vector (Vector{Float64}) of off-diagonal (hopping terms) chain coefficients.

### Returns

Matrix{Float64}: This matrix is the operator `oper` transformed back from the chain 
representation to the representation corresponding to the extended bath. The resulting 
operator represents quantities like mode occupations or other properties in the basis 
of environmental modes associated with specific frequencies ``\omega_i``.

### Description

This function performs a basis transformation of the operator `oper`. Specifically, 
this transformation reverses the unitary transformation that maps the extended bath
Hamiltonian into the chain representation.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L196-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.physical_occup-NTuple{6, Any}" href="#MPSDynamics.physical_occup-NTuple{6, Any}"><code>MPSDynamics.physical_occup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">physical_occup(corr_constr, corr_destr, omega, occup, b, M)

Calculates the physical occupation based on correlation matrices, omega values, 
and other parameters. The physical occupation in the original frequency environment
is computed by reverting the thermofield transformation.

# Arguments
- `corr_constr::Matrix{ComplexF64}`: The correlation construction matrix.
- `corr_destr::Matrix{ComplexF64}`: The correlation destruction matrix.
- `omega::Vector{Float64}`: The omega values.
- `occup::Matrix{Float64}`: The occupation matrix.
- `b::Float64`: The beta parameter.
- `M::Int`: The number of points for interpolation.

# Returns
- `Vector{Float64}`: The physical occupation values.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L262-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randisometry-Tuple{Type, Int64, Int64}" href="#MPSDynamics.randisometry-Tuple{Type, Int64, Int64}"><code>MPSDynamics.randisometry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randisometry([T=Float64], dims...)</code></pre><p>Construct a random isometry</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L470-L473">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.rmsd-Tuple{Any, Any}" href="#MPSDynamics.rmsd-Tuple{Any, Any}"><code>MPSDynamics.rmsd</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmsd(dat1::Vector{Float64}, dat2::Vector{Float64})</code></pre><p>Calculate the root mean squared difference between two measurements of an observable over the same time period.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L391-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.sineh-Tuple{Any, Any}" href="#MPSDynamics.sineh-Tuple{Any, Any}"><code>MPSDynamics.sineh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sineh(omega, bet)

Calculates the hyperbolic sine function function based on the input parameters, 
for the Bogoliubov transformation necessary for the thermofield transformation.

# Arguments
- `omega::Float64`: The frequency parameter.
- `bet::Float64`: The beta parameter.

# Returns
- `Float64`: The result of the modified cosine function.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L245-L257">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.therHam-Tuple{Any, Any, Any}" href="#MPSDynamics.therHam-Tuple{Any, Any, Any}"><code>MPSDynamics.therHam</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> function therHam(psi, site1, site2)</code></pre><p>Calculates Hβ such that ρ = e^(-βH) for some density matrix ρ obatined from tracing out everything outside the range [site1,site2] in the MPS psi</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/fundamentals.jl#L95-L99">source</a></section></article><h2 id="Tree-Tensor-Network-(TTN)"><a class="docs-heading-anchor" href="#Tree-Tensor-Network-(TTN)">Tree Tensor Network (TTN)</a><a id="Tree-Tensor-Network-(TTN)-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Tensor-Network-(TTN)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.addchild!-Tuple{MPSDynamics.Tree, Int64}" href="#MPSDynamics.addchild!-Tuple{MPSDynamics.Tree, Int64}"><code>MPSDynamics.addchild!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchild!(tree::Tree, id::Int)</code></pre><p>Add child to node <code>id</code> of <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeBasics.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree, Int64, Int64}" href="#MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree, Int64, Int64}"><code>MPSDynamics.addchildren!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addchildren!(tree::Tree, id::Int, n::Int)</code></pre><p>Add <code>n</code> children to node <code>id</code> of <code>tree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeBasics.jl#L54-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode, Int64}" href="#MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode, Int64}"><code>MPSDynamics.findchild</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findchild(node::TreeNode, id::Int)</code></pre><p>Return integer corresponding to the which number child site <code>id</code> is of <code>node</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeBasics.jl#L222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randtree-Tuple{Int64, Int64}" href="#MPSDynamics.randtree-Tuple{Int64, Int64}"><code>MPSDynamics.randtree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randtree(numnodes::Int, maxdegree::Int)</code></pre><p>Construct a random tree with <code>nummodes</code> modes and max degree <code>maxdegree</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeBasics.jl#L353-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Int64}" href="#MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Int64}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(net::TreeNetwork, O, id::Int)</code></pre><p>For a Tree, compute the local expectation value of a one-site operator O for site id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeMeasure.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Tuple{Int64, Int64}}" href="#MPSDynamics.measure1siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Tuple{Int64, Int64}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(net::TreeNetwork, O, sites::Tuple{Int,Int})</code></pre><p>For a Tree, compute the local expectation value of a one-site operator O for the specified site range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeMeasure.jl#L18-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Any, Tuple{Int64, Int64}}" href="#MPSDynamics.measure2siteoperator-Tuple{MPSDynamics.TreeNetwork, Any, Any, Tuple{Int64, Int64}}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure2siteoperator(net::TreeNetwork, O1, O2, sites::Tuple{Int,Int})</code></pre><p>For a Tree, compute the local expectation value of two one-site operators O1 and O2 for the specified site range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeMeasure.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.bonddims-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.bonddims-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.bonddims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bonddims(A::TreeNetwork)</code></pre><p>Return the bon-dimension of a tree-MPS <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L638-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsembed!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsembed!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsembed!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsembed(A::TreeNetwork, Dmax::Int)</code></pre><p>Embed tree-MPS <code>A</code> in manifold of max bond-dimension <code>Dmax</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L607-L612">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsmixednorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmixednorm!(A::TreeNetwork, id::Int)</code></pre><p>Normalise tree-MPS <code>A</code> such that orthogonality centre is on site <code>id</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsmoveoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsmoveoc!(A::TreeNetwork, id::Int)</code></pre><p>Move the orthogonality centre of right normalised tree-MPS <code>A</code> to site <code>id</code>.</p><p>This function will be more efficient than using <code>mpsmixednorm!</code> if the tree-MPS is already right-normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.mpsrightnorm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsrightnorm!(A::TreeNetwork)</code></pre><p>When applied to a tree-MPS, right normalise towards head-node.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L58-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork, Int64}" href="#MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork, Int64}"><code>MPSDynamics.mpsshiftoc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mpsshiftoc!(A::TreeNetwork, newhd::Int)</code></pre><p>Shift the orthogonality centre by one site, setting new head-node <code>newhd</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L92-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.normmps</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normmps(net::TreeNetwork; mpsorthog=:None)</code></pre><p>When applied to a tree-MPS <code>mpsorthog=:Left</code> is not defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.physdims-Tuple{MPSDynamics.TreeNetwork}" href="#MPSDynamics.physdims-Tuple{MPSDynamics.TreeNetwork}"><code>MPSDynamics.physdims</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">physdims(M::TreeNetwork)</code></pre><p>Return the physical dimensions of a tree-MPS or tree-MPO <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.productstatemps" href="#MPSDynamics.productstatemps"><code>MPSDynamics.productstatemps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">productstatemps(tree_::Tree, physdims::Dims, Dmax::Int=1; state=:Vacuum)</code></pre><p>Return a tree-MPS representing a product state with local Hilbert space dimensions given by <code>physdims</code>.</p><p>By default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, <code>Dmax</code> can be set accordingly.</p><p>The indvidual states of the MPS sites can be provided by setting <code>state</code> to a list of column vectors. Setting <code>state=:Vacuum</code> will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting <code>state=:FullOccupy</code> will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ψ = unitcol(1,2); d = 6; N = 30; α = 0.1; Δ = 0.0; ω0 = 0.2; s = 1

julia&gt; cpars = chaincoeffs_ohmic(N, α, s)

julia&gt; H = spinbosonmpo(ω0, Δ, d, N, cpars, tree=true)

julia&gt; A = productstatemps(H.tree, physdims(H), state=[ψ, fill(unitcol(1,d), N)...]) # tree-MPS representation of |ψ&gt;|Vacuum&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L540-L565">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.randmps" href="#MPSDynamics.randmps"><code>MPSDynamics.randmps</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">randmps(tree::Tree, physdims, Dmax::Int, T::Type{&lt;:Number} = Float64)</code></pre><p>Construct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by <code>Dmax</code>.</p><p>The local Hilbert space dimensions are specified by physdims which can either be of type <code>Dims{length(tree)}</code>, specifying the dimension of each site, or of type <code>Int</code>, in which case the same local dimension is used for every site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L127-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.tdvp1sweep!-Tuple{Any, MPSDynamics.TreeNetwork, MPSDynamics.TreeNetwork, Vector, Int64}" href="#MPSDynamics.tdvp1sweep!-Tuple{Any, MPSDynamics.TreeNetwork, MPSDynamics.TreeNetwork, Vector, Int64}"><code>MPSDynamics.tdvp1sweep!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tdvp1sweep!(dt, A::TreeNetwork, M::TreeNetwork, F::Vector, id::Int; verbose=false, kwargs...)</code></pre><p>Propagates the tree-MPS A with the tree-MPO M following the 1-site TDVP method. The sweep is done back and forth with a time step dt/2. F represents the merged left and right parts of the site being propagated.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/treeTDVP.jl#L272-L276">source</a></section></article><h2 id="Measure-and-Obervables"><a class="docs-heading-anchor" href="#Measure-and-Obervables">Measure and Obervables</a><a id="Measure-and-Obervables-1"></a><a class="docs-heading-anchor-permalink" href="#Measure-and-Obervables" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}" href="#MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}"><code>MPSDynamics.OneSiteObservable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OneSiteObservable(name,op,sites)</code></pre><p>Computes the local expectation value of the one-site operator <code>op</code> on the specified sites. Used to define one-site observables that are obs and convobs parameters for the <code>runsim</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.OneSiteObservable-Tuple{Any, Any}" href="#MPSDynamics.OneSiteObservable-Tuple{Any, Any}"><code>MPSDynamics.OneSiteObservable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">OneSiteObservable(name,op)</code></pre><p>Computes the local expectation value of the one-site operator <code>op</code> on the every site. Used to define one-site observables that are obs and convobs parameters for the <code>runsim</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.TwoSiteObservable" href="#MPSDynamics.TwoSiteObservable"><code>MPSDynamics.TwoSiteObservable</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TwoSiteObservable(name,op1,op2,sites1=nothing,sites2=nothing)</code></pre><p>Computes the local expectation value of operators <code>op1</code> and <code>op2</code> where <code>op1</code> acts on sites1 and <code>op2</code> acts on sites2. Used to define several-site observables that are obs and convobs parameters for the <code>runsim</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L52-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Any, OneSiteObservable}" href="#MPSDynamics.measure-Tuple{Any, OneSiteObservable}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure(A, O; kwargs...)</code></pre><p>Measure observable <code>O</code> on mps state <code>A</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L132-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Vector, Vector}" href="#MPSDynamics.measure-Tuple{Vector, Vector}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> measure(A::Vector, Os::Vector; kwargs...)</code></pre><p>Caculate expectation of Os on MPS A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L983-L988">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Int64}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Int64}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A::Vector, O, site::Int)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for a single site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L268-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Tuple{Int64, Int64}}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Tuple{Int64, Int64}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A::Vector, O, chainsection::Tuple{Int64,Int64})</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for a chainsection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L212-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Vector{Int64}}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Vector{Int64}}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A::Vector, O, sites::Vector{Int})</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if it is specified.</p><p>For calculating operators on single sites this will be more efficient if the site is on the left of the mps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L187-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure1siteoperator-Tuple{Vector, Any}" href="#MPSDynamics.measure1siteoperator-Tuple{Vector, Any}"><code>MPSDynamics.measure1siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure1siteoperator(A::Vector, O)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L247-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Int64, Int64}" href="#MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Int64, Int64}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> measure2siteoperator(A::Vector, M1, M2, j1, j2)</code></pre><p>Caculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L285-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Vector{Int64}, Vector{Int64}}" href="#MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Vector{Int64}, Vector{Int64}}"><code>MPSDynamics.measure2siteoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> measure2siteoperator(A::Vector, M1, M2, sites1::Vector{Int}, sites2::Vector{Int})</code></pre><p>Caculate expectation of M1*M2 where M1 acts on sites1 and M2 acts on sites2, assumes A is right normalised.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L464-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measurempo-Tuple{Vector, Vector, Tuple{Int64, Int64}}" href="#MPSDynamics.measurempo-Tuple{Vector, Vector, Tuple{Int64, Int64}}"><code>MPSDynamics.measurempo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measurempo(A::Vector, M::Vector, sites::Tuples{Int,Int})</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of the MPO M on specified sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measurempo-Tuple{Vector, Vector}" href="#MPSDynamics.measurempo-Tuple{Vector, Vector}"><code>MPSDynamics.measurempo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measurempo(A::Vector, M::Vector)</code></pre><p>For a list of tensors <code>A</code> representing a right orthonormalized MPS, compute the local expectation value of the MPO M on every site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L94-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.rhoreduced_1site" href="#MPSDynamics.rhoreduced_1site"><code>MPSDynamics.rhoreduced_1site</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia"> rhoreduced_1site(A::Vector, site::Int=1)</code></pre><p>Caculate the reduced density matrix of the MPS A at the specified site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L1022-L1027">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.rhoreduced_2sites-Tuple{Vector, Tuple{Int64, Int64}}" href="#MPSDynamics.rhoreduced_2sites-Tuple{Vector, Tuple{Int64, Int64}}"><code>MPSDynamics.rhoreduced_2sites</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia"> rhoreduced_2sites(A::Vector, site::Tuple{Int, Int})</code></pre><p>Caculate the reduced density matrix of the MPS A of two neigbour sites. The resulting dimensions will be the four physical dimensions in total,  corresponding to the dimensions  of the two sites</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/measure.jl#L1046-L1052">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.measure-Tuple{Any, FockError}" href="#MPSDynamics.measure-Tuple{Any, FockError}"><code>MPSDynamics.measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">measure(A, obs::FockError; t=0, kwargs...)</code></pre><p>Return the measure of the observable obs on the MPS A. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/observables.jl#L20-L25">source</a></section></article><h2 id="Models-and-Hamiltonians-(MPO)"><a class="docs-heading-anchor" href="#Models-and-Hamiltonians-(MPO)">Models and Hamiltonians (MPO)</a><a id="Models-and-Hamiltonians-(MPO)-1"></a><a class="docs-heading-anchor-permalink" href="#Models-and-Hamiltonians-(MPO)" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chaincoeffs_ohmic-Tuple{Any, Any, Any}" href="#MPSDynamics.chaincoeffs_ohmic-Tuple{Any, Any, Any}"><code>MPSDynamics.chaincoeffs_ohmic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chaincoeffs_ohmic(N, α, s; ωc=1, soft=false)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for an Harmonic bath at zero temperature with a power law spectral density given by:</p><p>soft cutoff: <span>$J(ω) = 2αω_c (\frac{ω}{ω_c})^s \exp(-ω/ω_c)$</span> </p><p>hard cutoff: <span>$J(ω) = 2αω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span></p><p>The coefficients parameterise the chain Hamiltonian</p><p><span>$H = H_S + c_0 A_S⊗B_0+\sum_{i=0}^{N-1}t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N} ϵ_ib_i^\dagger b_i$</span></p><p>which is unitarily equivalent (before the truncation to <code>N</code> sites) to</p><p><span>$H = H_S + A_S⊗\int_0^∞dω\sqrt{J(ω)}B_ω + \int_0^∞dωωb_ω^\dagger b_ω$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L483-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.correlatedenvironmentmpo-Tuple{Vector, Int64, Int64}" href="#MPSDynamics.correlatedenvironmentmpo-Tuple{Vector, Int64, Int64}"><code>MPSDynamics.correlatedenvironmentmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">correlatedenvironmentmpo(R::Vector, Nm::Int, d::Int; chainparams, fnamecc::String, s=1, α=1, ωc=1, c_phonon=1, β=&quot;inf&quot;, issoft=false)</code></pre><p>Generate a MPO for a one-dimensional bosonic bath spatially correlated to a multi-component system </p><p><span>$H_B + H_{int} = \int_{-∞}^{+∞} dk ω_k b_k^\dagger b_k + ∑_j \int_{-∞}^{+∞}dk \sqrt{J(k)}(A_j b_k e^{i k R_j} + h.c.)$</span>.</p><p>The interactions between the system and the chain-mapped bath are long range, i.e. each site interacts with all the chain modes. The spectral density is assumed to be Ohmic <span>$J(ω) = 2αωc(ω/ωc)^s$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>R</code>: List of system&#39;s components positions</li><li><code>Nm</code>: Number of chain modes. The actual number of mode will be doubled to account for the left and right moving excitations.</li><li><code>d</code>: Local Hilbert space dimension of the bath modes</li><li><code>chainparams</code>: chain parameters, of the form <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</li><li><code>fnamecc</code>: Path to a file containing pre-computed long-range coupling coefficient. If not provided, the coupling coefficients will be computed and stored.</li><li><code>s</code>: Ohmicity</li><li><code>α</code>: Kondo parameter</li><li><code>ωc</code>: Bath cut-off frequency</li><li><code>c_phonon</code>: Speed of sound in the bath</li><li><code>β</code>: Inverse temperature </li><li><code>issoft</code>: Is the cut-off of the Ohmic SD soft or hard?</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L988-L1012">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.hbathchain-Tuple{Int64, Int64, Any, Vararg{Any}}" href="#MPSDynamics.hbathchain-Tuple{Int64, Int64, Any, Vararg{Any}}"><code>MPSDynamics.hbathchain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hbathchain(N::Int, d::Int, chainparams, longrangecc...; tree=false, reverse=false, coupletox=false)</code></pre><p>Generate MPO representing a tight-binding chain of <code>N</code> oscillators with <code>d</code> Fock states each. Chain parameters are supplied in the standard form: <code>chainparams</code> <span>$=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>. The output does not itself represent a complete MPO but will possess an end which is <em>open</em> and should be attached to another tensor site, usually representing the <em>system</em>.</p><p><strong>Arguments</strong></p><ul><li><code>reverse</code>: If <code>reverse=true</code> create a chain were the last (i.e. Nth) site is the site which couples to the system</li><li><code>coupletox</code>: Used to choose the form of the system coupling. <code>coupletox=true</code> gives a non-number conserving coupling of the form <span>$H_{\text{I}}= A_{\text{S}}(b_{0}^\dagger + b_0)$</span> where <span>$A_{\text{S}}$</span> is a system operator, while <code>coupletox=false</code> gives the number-converving coupling <span>$H_{\text{I}}=(A_{\text{S}} b_{0}^\dagger + A_{\text{S}}^\dagger b_0)$</span></li><li><code>tree</code>: If <code>true</code> the resulting chain will be of type <code>TreeNetwork</code>; useful for construcing tree-MPOs </li></ul><p><strong>Example</strong></p><p>One can constuct a system site tensor to couple to a chain by using the function <code>up</code> to populate the tensor. For example, to construct a system site with Hamiltonian <code>Hs</code> and coupling operator <code>As</code>, the system tensor <code>M</code> is constructed as follows for a non-number conserving interaction:</p><pre><code class="language-julia">u = one(Hs) # system identity
M = zeros(1,3,2,2)
M[1, :, :, :] = up(Hs, As, u)</code></pre><p>The full MPO can then be constructed with:</p><pre><code class="language-julia">Hmpo = [M, hbathchain(N, d, chainparams, coupletox=true)...]</code></pre><p>Similarly for a number conserving interaction the site tensor would look like:</p><pre><code class="language-julia">u = one(Hs) # system identity
M = zeros(1,4,2,2)
M[1, :, :, :] = up(Hs, As, As&#39;, u)</code></pre><p>And the full MPO would be</p><pre><code class="language-julia">Hmpo = [M, hbathchain(N, d, chainparams; coupletox=false)...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L180-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.heisenbergmpo" href="#MPSDynamics.heisenbergmpo"><code>MPSDynamics.heisenbergmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">heisenbergmpo(N::Int, J=1.0) = xyzmpo(N; Jx=J)</code></pre><p>Generate MPO for the <code>N</code>-spin Heisenberg XXX model, defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J σ_x^{n} σ_x^{n+1} - J σ_y^{n} σ_y^{n+1} - J σ_z^{n} σ_z^{n+1}$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L55-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.ibmmpo-NTuple{4, Any}" href="#MPSDynamics.ibmmpo-NTuple{4, Any}"><code>MPSDynamics.ibmmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ibmmpo(ω0, d, N, chainparams; tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to a chain of harmonic oscillators with the interacting boson model (IBM), defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z +  c_0σ_z(b_0^\dagger+b_0) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N} ϵ_ib_i^\dagger b_i$</span>.</p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + σ_z\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ dω ωb_ω^\dagger b_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L571-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.interleaved_tightbinding_mpo-NTuple{4, Any}" href="#MPSDynamics.interleaved_tightbinding_mpo-NTuple{4, Any}"><code>MPSDynamics.interleaved_tightbinding_mpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">interleaved_tightbinding_mpo(N, ϵd, chainparams1, chainparams2)

Generate MPO for a tight-binding chain of N fermionic sites with a single impurity site (fermionic as well)
of energy ϵd. The impurity is coupled to two leads, each described by a set of chain parameters. 
The interactions are next-nearest-neighbour, with the first site corresponding to the impurity, and the
two chains organised in an interleaved fashion.

# Arguments

* `N::Int`: number of sites in the chain
* `ϵd::Real`: energy of the impurity site at the first site, as Ed - μ, where μ is the chemical potential
* chainparams1::Array{Real,1}: chain parameters for the first lead
* chainparams2::Array{Real,1}: chain parameters for the second lead

The chain parameters are given in the standard form: `chainparams` ``=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]``.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L857-L873">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.isingmpo-Tuple{Int64}" href="#MPSDynamics.isingmpo-Tuple{Int64}"><code>MPSDynamics.isingmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isingmpo(N; J=1.0, h=1.0)</code></pre><p>Generate MPO for the <code>N</code>-spin 1D Ising model with external field <span>$\vec{h} = (0,0,h)$</span>, defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J_x σ_x^{n} σ_x^{n+1} + \sum_{n=1}^{N}(- h_z σ_z^{n})$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L42-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.longrange_isingmpo" href="#MPSDynamics.longrange_isingmpo"><code>MPSDynamics.longrange_isingmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">longrange_isingmpo(N::Int, α::Float64=0.; J=1.0, h=1.0) = longrange_xyzmpo(N, α; Jx=J, Jy=0., Jz=0., hz=h, hx=0.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L121-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.longrange_xyzmpo" href="#MPSDynamics.longrange_xyzmpo"><code>MPSDynamics.longrange_xyzmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">longrange_xyzmpo(N::Int, α::Float64=0.; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)</code></pre><p>Gennerate MPO for the <code>N</code>-spin long-range XYZ model with external field <span>$\vec{h}=(h_x, 0, h_z)$</span>, , defined by the Hamiltonian</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L83-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.nearestneighbourmpo" href="#MPSDynamics.nearestneighbourmpo"><code>MPSDynamics.nearestneighbourmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearestneighbourmpo(N::Int, h0, A, Ad = A&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L645-L652">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.nearestneighbourmpo" href="#MPSDynamics.nearestneighbourmpo"><code>MPSDynamics.nearestneighbourmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nearestneighbourmpo(tree_::Tree, h0, A, Ad = A&#39;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L669-L676">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.protontransfermpo-NTuple{11, Any}" href="#MPSDynamics.protontransfermpo-NTuple{11, Any}"><code>MPSDynamics.protontransfermpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">protontransfermpo(ω0e,ω0k,x0e,x0k, Δ, dRC, d, N, chainparams, RCparams, λreorg)</code></pre><p>Generate a MPO for a system described in space with a reaction coordinate (RC) tensor. The RC tensor is coupled to a bosonic bath, taking into account the induced reorganization energy. </p><p><span>$H_S + H_{RC} + H_{int}^{S-RC} = \omega^0_{e} |e\rangle \langle e| + \omega^0_{k} |k\rangle \langle k| + \Delta (|e\rangle \langle k| + |k\rangle \langle e|) + \omega_{RC} (d^{\dagger}d + \frac{1}{2}) + g_{e} |e\rangle \langle e|( d + d^{\dagger})+ g_{k} |k \rangle \langle k|( d + d^{\dagger})$</span> <span>$H_B + H_{int}^{RC-B} = \int_{-∞}^{+∞} dk ω_k b_k^\dagger b_k - (d + d^{\dagger})\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \lambda_{reorg}(d + d^{\dagger})^2$</span>. <span>$\lambda_{reorg} = \int \frac{J(\omega)}{\omega}d\omega$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ω0e</code>: enol energy at x=0 </li><li><code>ω0k</code>: keto energy at x=0</li><li><code>x0e</code>: enol equilibrium displacement</li><li><code>x0k</code>: keto equilibrium displacement </li><li><code>Δ</code>: direct coupling between enol and keto</li><li><code>dRC</code>: fock space of the RC tensor </li><li><code>d</code>: number of Fock states of the chain modes</li><li><code>N</code>: length of the chain</li><li><code>chainparams</code>: chain parameters, of the form <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature. </li><li><code>RCparams</code>: RC tensor parameter, of the form <code>RCparams</code>=<span>$[ωRC,-g/x]$</span> </li><li><code>λreorg</code>: reorganization energy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L1333-L1362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.puredephasingmpo-NTuple{4, Any}" href="#MPSDynamics.puredephasingmpo-NTuple{4, Any}"><code>MPSDynamics.puredephasingmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">puredephasingmpo(ΔE, dchain, Nchain, chainparams; tree=false)</code></pre><p>Generate MPO for a pure dephasing model, defined by the Hamiltonian <span>$H = \frac{ΔE}{2} σ_z +  \frac{σ_z}{2} c_0 (b_0^\dagger + b_0) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N-1} ϵ_i b_i^\dagger b_i$</span></p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p><strong>Arguments</strong></p><pre><code class="language-none">* `ΔE::Real`: energy splitting of the spin
* `dchain::Int`: physical dimension of the chain sites truncated Hilbert spaces
* `Nchain::Int`: number of sites in the chain
* `chainparams::Array{Real,1}`: chain parameters for the bath chain. The chain parameters are given in the standard form: `chainparams` ``=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]``.
* `tree::Bool`: if true, return a `TreeNetwork` object, otherwise return a vector of MPO tensors</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L708-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.readchaincoeffs-Tuple{Any, Vararg{Any}}" href="#MPSDynamics.readchaincoeffs-Tuple{Any, Vararg{Any}}"><code>MPSDynamics.readchaincoeffs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readchaincoeffs(fdir, params...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L543-L549">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.spinbosonmpo-NTuple{5, Any}" href="#MPSDynamics.spinbosonmpo-NTuple{5, Any}"><code>MPSDynamics.spinbosonmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spinbosonmpo(ω0, Δ, d, N, chainparams; rwa=false, tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to a chain of harmonic oscillators, defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + c_0σ_x(b_0^\dagger+b_0) + \sum_{i=0}^{N-1} t_i (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N} ϵ_ib_i^\dagger b_i$</span>.</p><p>The spin is on site 1 of the MPS and the bath modes are to the right.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + Δσ_x + σ_x\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ dω ωb_ω^\dagger b_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature.</p><p>The rotating wave approximation can be made by setting <code>rwa=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L398-L419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.spinchainmpo-Tuple{Int64}" href="#MPSDynamics.spinchainmpo-Tuple{Int64}"><code>MPSDynamics.spinchainmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spinchainmpo(N::Int; J=1.0, hz=1.0, hx=0.0, i=div(N,2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L127-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.tightbinding_mpo-NTuple{4, Any}" href="#MPSDynamics.tightbinding_mpo-NTuple{4, Any}"><code>MPSDynamics.tightbinding_mpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tightbinding_mpo(N, ϵd, chainparams1, chainparams2)</code></pre><p>Generate MPO for a tight-binding chain of N fermionic sites with a single impurity site (fermionic as well)  of energy ϵd at the center. The impurity is coupled to two leads, each described by a set of chain parameters. The interactions are nearest-neighbour, with the first N/2-1 sites corresponding to the first lead, the Nth site corresponding to the impurity, and the rest of the sites corresponding to the second lead.</p><p><strong>Arguments</strong></p><pre><code class="language-none">* `N::Int`: number of sites in the chain
* `ϵd::Real`: energy of the impurity site at the center, as Ed - μ, where μ is the chemical potential
* chainparams1::Array{Real,1}: chain parameters for the first lead
* chainparams2::Array{Real,1}: chain parameters for the second lead</code></pre><p>The chain parameters are given in the standard form: <code>chainparams</code> <span>$=[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L737-L752">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}" href="#MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}"><code>MPSDynamics.tightbindingmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tightbindingmpo(N::Int, d::Int; J=1.0, e=1.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.tunnelingmpo-Tuple{Any, Any, Any, Any, Any, Int64, Int64}" href="#MPSDynamics.tunnelingmpo-Tuple{Any, Any, Any, Any, Any, Int64, Int64}"><code>MPSDynamics.tunnelingmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tunnelingmpo(ϵ, delta, α, s, β, d::Int, nummodes::Int; tree=false, ωc=1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L613-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.twobathspinmpo" href="#MPSDynamics.twobathspinmpo"><code>MPSDynamics.twobathspinmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">twobathspinmpo(ω0, Δ, Nl, Nr, dl, dr, chainparamsl=[fill(1.0,N),fill(1.0,N-1), 1.0], chainparamsr=chainparamsl; tree=false)</code></pre><p>Generate MPO for a spin-1/2 coupled to two chains of harmonic oscillators, defined by the Hamiltonian</p><p><span>$H = \frac{ω_0}{2}σ_z + Δσ_x + c_0^rσ_x(b_0^\dagger+b_0) + \sum_{i=0}^{N_r-1} t_i^r (b_{i+1}^\dagger b_i +h.c.) + \sum_{i=0}^{N_r} ϵ_i^rb_i^\dagger b_i + c_0^lσ_x(d_0^\dagger+d_0) + \sum_{i=0}^{N_l-1} t_i^l (d_{i+1}^\dagger d_i +h.c.) + \sum_{i=0}^{N_l} ϵ_i^l d_i^\dagger d_i$</span>.</p><p>The spin is on site <span>$N_l + 1$</span> of the MPS, surrounded by the left chain modes and the right chain modes.</p><p>This Hamiltonain is unitarily equivalent (before the truncation to <code>N</code> sites) to the spin-boson Hamiltonian defined by</p><p><span>$H =  \frac{ω_0}{2}σ_z + Δσ_x + σ_x\int_0^∞ dω\sqrt{J(ω)}(b_ω^\dagger+b_ω) + \int_0^∞ dω ωb_ω^\dagger b_ωi + σ_x\int_0^∞ dω\sqrt{J^l(ω)}(d_ω^\dagger+d_ω) + \int_0^∞ dω ωd_ω^\dagger d_ω$</span>.</p><p>The chain parameters, supplied by <code>chainparams</code>=<span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span>, can be chosen to represent any arbitrary spectral density <span>$J(ω)$</span> at any temperature. The two chains can have a different spectral density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L446-L465">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.xxzmpo" href="#MPSDynamics.xxzmpo"><code>MPSDynamics.xxzmpo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">xxzmpo(N::Int, Δ = 1.0, J=1.0) = xyzmpo(N; Jx=J, Jy=J, Jz=J*Δ)</code></pre><p>Generate MPO for the <code>N</code>-spin XXZ model, defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J σ_x^{n} σ_x^{n+1} - J σ_y^{n} σ_y^{n+1} - \Delta J σ_z^{n} σ_z^{n+1}$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L69-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.xyzmpo-Tuple{Int64}" href="#MPSDynamics.xyzmpo-Tuple{Int64}"><code>MPSDynamics.xyzmpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">xyzmpo(N::Int; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)</code></pre><p>Generate MPO for the <code>N</code>-spin XYZ model with external field <span>$\vec{h}=(h_x, 0, h_z)$</span>, , defined by the Hamiltonian</p><p><span>$H = \sum_{n=1}^{N-1} -J_x σ_x^{n} σ_x^{n+1} - J_y σ_y^{n} σ_y^{n+1} - J_z σ_z^{n} σ_z^{n+1} + \sum_{n=1}^{N}(- h_x σ_x^{n} - h_z σ_z^{n})$</span></p><p>with <span>$σ_x^{n}, σ_y^{n}, σ_z^{n}$</span> the Pauli spin-1/2 matrices of the <span>$n^\text{th}$</span> site.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/models.jl#L4-L15">source</a></section></article><h2 id="Chain-Mapping"><a class="docs-heading-anchor" href="#Chain-Mapping">Chain-Mapping</a><a id="Chain-Mapping-1"></a><a class="docs-heading-anchor-permalink" href="#Chain-Mapping" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chaincoeffs_fermionic-Tuple{Any, Any, Any}" href="#MPSDynamics.chaincoeffs_fermionic-Tuple{Any, Any, Any}"><code>MPSDynamics.chaincoeffs_fermionic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">chaincoeffs_fermionic(nummodes, β, chain; ϵ=x, ωc=1, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=true)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for a fermionic bath at the inverse temperature β.</p><p><strong>Arguments</strong></p><ul><li>nummodes: Number of bath modes</li><li>β: inverse temperature</li><li>chain: 1 if the chain modes are empty, 2 if the chain modes are filled</li><li>ϵ: user-provided dispersion relation. Should be a function f(x) where x is the wavenumber</li><li>J: user-provided spectral density. Should be a function f(x) where x is the wavenumber</li><li>ωc: the maximum frequency allowwed in the spectral density</li><li>mc: the number of component intervals</li><li>mp: the number of points in the discrete part of the measure (mp=0 if there is none)</li><li>iq: a parameter to be set equal to 1, if the user provides his or her own quadrature routine, and different from 1 otherwise</li><li>idelta: a parameter whose default value is 1, but is preferably set equal to 2, if iq=1 and the user provides Gauss-type quadrature routines</li><li>procedure: choice between the Stieltjes and the Lanczos procedure</li><li>AB: component intervals</li><li>Mmax: maximum number of integration points</li><li>save: if true the coefficients are saved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/finitetemperature.jl#L120-L140">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.chaincoeffs_finiteT" href="#MPSDynamics.chaincoeffs_finiteT"><code>MPSDynamics.chaincoeffs_finiteT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">chaincoeffs_finiteT(nummodes, β, ohmic=true; α, s, J, ωc=1, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=true)</code></pre><p>Generate chain coefficients <span>$[[ϵ_0,ϵ_1,...],[t_0,t_1,...],c_0]$</span> for a harmonic bath at the inverse temperature β.</p><p>By default a Ohmic spectral density <span>$J(ω) = 2αω_c (\frac{ω}{ω_c})^s θ(ω-ω_c)$</span> is considered. Users can provide their own spectral density.</p><p><strong>Arguments</strong></p><ul><li>nummodes: Number of bath modes</li><li>β: inverse temperature</li><li>ohmic: true if the spectral density is Ohmic, false if the user provides its own spectral density</li><li>α: Kondo parameter of the Ohmic spectral density </li><li>s: ohmicity</li><li>J: user-provided spectral density. Should be a function f(x,i) where x is the frequency and i ∈ {1,...,mc} labels the intervals on which the SD is defined</li><li>ωc: the maximum frequency of the Ohmic spectral density</li><li>mc: the number of component intervals</li><li>mp: the number of points in the discrete part of the measure (mp=0 if there is none)</li><li>iq: a parameter to be set equal to 1, if the user provides his or her own quadrature routine, and different from 1 otherwise</li><li>idelta: a parameter whose default value is 1, but is preferably set equal to 2, if iq=1 and the user provides Gauss-type quadrature routines</li><li>procedure: choice between the Stieltjes and the Lanczos procedure</li><li>AB: component intervals</li><li>Mmax: maximum number of integration points</li><li>save: if true the coefficients are saved</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/finitetemperature.jl#L6-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.gauss-Tuple{Any, Any}" href="#MPSDynamics.gauss-Tuple{Any, Any}"><code>MPSDynamics.gauss</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gauss(N,ab)</code></pre><p>Gauss quadrature rule for <code>N</code> sites on an interval <code>ab</code>. Given a weight function w encoded by the <code>N</code>x2 array <code>ab</code> of the first <code>N</code> recurrence coefficients for the associated orthogonal polynomials, the first column of <code>ab</code> containing the <code>N</code> alpha-coefficients and the second column the <code>N</code> beta-coefficients, the call xw = gauss(N,ab) generates the nodes and weights xw of the <code>N</code>-point Gauss quadrature rule for the weight function w. The nodes, in increasing order, are stored in the first column, the n corresponding weights in the second column, of the <code>N</code>x2 array xw.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/ChainOhmT/gauss.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.lanczos-Tuple{Any, Any}" href="#MPSDynamics.lanczos-Tuple{Any, Any}"><code>MPSDynamics.lanczos</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lanczos(N,xw)</code></pre><p>Given the discrete inner product whose nodes are contained in the first column, and whose weights are contained in the second column, of the <code>N</code>x2 array <code>xw</code>, the call ab=lanczos(N,xw) generates the first <code>N</code> recurrence coefficients ab of the corresponding discrete orthogonal polynomials. The <code>N</code> alpha-coefficients are stored in the first column, the <code>N</code> beta-coefficients in the second column, of the <code>N</code>x2 array ab.</p><p>The script is adapted from the routine RKPW in W.B. Gragg and W.J. Harrod, ``The numerically stable reconstruction of Jacobi matrices from spectral data&#39;&#39;, Numer. Math. 44 (1984), 317-335.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/ChainOhmT/lanczos.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.stieltjes-Tuple{Any, Any}" href="#MPSDynamics.stieltjes-Tuple{Any, Any}"><code>MPSDynamics.stieltjes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stieltjes(N,xw)</code></pre><p>Discretized Stieltjes procedure. Given the discrete inner product whose nodes are contained in the first column, and whose weights are contained in the second column, of the <code>N</code>x2 array <code>xw</code>, the call ab=stieltjes(N,xw) generates the first <code>N</code> recurrence coefficients ab of the corresponding discrete orthogonal polynomials. The <code>N</code> alpha- coefficients are stored in the first column, the <code>N</code> beta-coefficients in the second column, of the <code>N</code>x2 array ab.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/ChainOhmT/stieltjes.jl#L1-L6">source</a></section></article><h2 id="Dynamics-propagation-function"><a class="docs-heading-anchor" href="#Dynamics-propagation-function">Dynamics propagation function</a><a id="Dynamics-propagation-function-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamics-propagation-function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MPSDynamics.runsim-NTuple{4, Any}" href="#MPSDynamics.runsim-NTuple{4, Any}"><code>MPSDynamics.runsim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">runsim(dt, tmax, A, H; 
	method=:TDVP1, 
	machine=LocalMachine(), 
	params=[], 
	obs=[], 
	convobs=[],
            convparams=error(&quot;Must specify convergence parameters&quot;),
            save=false,
            plot=save,
            savedir=string(homedir(),&quot;/MPSDynamics/&quot;),
            unid=randstring(5),
            name=nothing,
	kwargs...
	)</code></pre><p>Propagate the MPS <code>A</code> with the MPO <code>H</code> up to time <code>tmax</code> in time steps of <code>dt</code>. The final MPS is returned to <code>A</code> and the measurement data is returned to <code>dat</code> </p><p><strong>Arguments</strong></p><ul><li><code>method</code>: Several methods are implemented in MPSDynamics. <code>:TDVP1</code> refers to 1-site TDVP on tree and chain MPS, <code>:TDVP2</code> refers to 2-site TDVP on chain MPS, <code>:DTDVP</code> refers to a variant of 1-site TDVP with dynamics bond-dimensions on chain MPS</li><li><code>machine</code>: <code>LocalMachine()</code> points local ressources, <code>RemoteMachine()</code> points distant ressources</li><li><code>params</code>: list of parameters written in the log.txt file to describe the dynamics. Can be listed with @LogParams(). </li><li><code>obs</code>: list of observables that will be measured at every time step for the most accurate convergence parameter supplied to <code>convparams</code> </li><li><code>convobs</code>: list of observables that will be measure at every time step for every convergence parameter supplied to <code>convparams</code> </li><li><code>convparams</code>: list of convergence parameter with which the propagation will be calculated for every parameter. At each parameter, <code>convobs</code> are measured while <code>obs</code> are measured only for the most accurate dynamics</li><li><code>save</code>: Used to choose whether the data will also be saved to a file  </li><li><code>plot</code>: Used to choose whether plots for 1D observables will be automatically generated and saved along with the data</li><li><code>savedir</code>: Used to specify the path where resulting files are stored</li><li><code>unid</code>: Used to specify the name of the directory containing the resulting files</li><li><code>name</code>: Used to describe the calculation. This name will appear in the log.txt file</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/shareloqs/MPSDynamics/blob/119ec67002a89d7b176b3ac68b59036ad8d3411b/src/MPSDynamics.jl#L32-L64">source</a></section></article><h2 id="Advanced"><a class="docs-heading-anchor" href="#Advanced">Advanced</a><a id="Advanced-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced" title="Permalink"></a></h2></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theory/">« Theoretical Background</a><a class="docs-footer-nextpage" href="../dev/">Developers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 12 June 2024 09:36">Wednesday 12 June 2024</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
