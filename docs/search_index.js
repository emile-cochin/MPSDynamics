var documenterSearchIndex = {"docs":
[{"location":"dev/#Developpers","page":"Developpers","title":"Developpers","text":"","category":"section"},{"location":"dev/#Simulation-Workflow","page":"Developpers","title":"Simulation Workflow","text":"","category":"section"},{"location":"dev/","page":"Developpers","title":"Developpers","text":"The flow chart will go here","category":"page"},{"location":"dev/#How-to-Contribute","page":"Developpers","title":"How to Contribute","text":"","category":"section"},{"location":"dev/","page":"Developpers","title":"Developpers","text":"Contributions are welcome! Don't hesitate to contact us if you","category":"page"},{"location":"dev/","page":"Developpers","title":"Developpers","text":"found a bug;\nhave a suggestion on how to improve the code and/or documentation;\nwould like to get involved in writing code and/or documentation.","category":"page"},{"location":"dev/","page":"Developpers","title":"Developpers","text":"You can contact us by raising an issue on Github, or by writing to one of the developpers.","category":"page"},{"location":"theory/#Theoretical-Background","page":"Theoretical Background","title":"Theoretical Background","text":"","category":"section"},{"location":"theory/#Chain-Mapping-of-bosonic-environments","page":"Theoretical Background","title":"Chain-Mapping of bosonic environments","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"We consider, in the Schr√∂dinger picture, a general Hamiltonian where a non-specified system interacts linearly with a bosonic environments","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"beginaligned\n    hatH = hatH_S + int_0^+infty hbaromegahata^dagger_omegahata_omega mathrmdomega + hatA_Sint_0^+inftysqrtJ(omega)left(hata_omega + hata^dagger_omegaright)mathrmdomega\nendaligned","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where hata_omega (hata^dagger_omega) is a bosonic annihilation (creation) operator for a normal mode of the environment of energy hbaromega, hatA_S is a system operator, and J(omega) = sum_k g_k^2delta(omega - omega_k) is the bath spectral density (SD), defined with the microscopic system-environment coupling strength g_k. The SD quantifies the coupling strengths of the different normal modes of the environment with the system. Any SD that is not flat corresponds to a non-Markovian environment.","category":"page"},{"location":"theory/#Zero-Temperature","page":"Theoretical Background","title":"Zero Temperature","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Let us consider the Hamiltonian presented in Eq.(1). We can introduce a unitary transformation of the continuous normal modes hata_omega to an infinite discrete set of interacting modes hatb_n[chin_exact_2010].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hata_omega = sum_n=0^+infty U_n(omega)hatb_n = sum_n=0^+infty sqrtJ(omega)P_n(omega)hatb_n ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where P_n(omega) are orthonormal polynomials such that","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    int_0^+inftyP_n(omega)P_m(omega)J(omega)mathrmdomega = delta_nm ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"and the inverse transformation is","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hatb_n = int_0^+infty U_n(omega)hata_omegamathrmdomega ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Note that the orthonormality of the polynomials ensures the unitarity of the transformation defined in Eq.(2). The mapping from a continuous set of modes to a (still infinite) discrete set might seem counter-intuitive, however it is a direct consequence of the separability of the underlying Hilbert space.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Under this transformation, the Hamiltonian in Eq.(1) becomes","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hatH= hatH_S + sum_n=0^+inftyvarepsilon_nhatb_n^daggerhatb_n + t_n(hatb_n+1^daggerhatb_n + mathrmhc) + kappahatA_S(hatb_0 + hatb_0^dagger) ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Hence, this mapping transforms the normal bath Hamiltonian into a tight-binding Hamiltonian with on-site energies varepsilon_n and hopping energies t_n. Another important consequence of this mapping is that now the system only interacts with the first mode n = 0 of the chain-mapped environment. The chain coefficients varepsilon_n, t_n, and the coupling kappa depend solely on the SD.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This makes chain mapping a tool of choice for describing systems coupled to environment with highly structured SD (e.g. experimentally measured or calculated ab initio)[chin_role_2013][alvertis_nonequilibrium_2019][dunnett_influence_2021][caycedosoler_exact_2022]. In this new representation, the Hamiltonian in Eq.(5) has naturally a 1D chain topology. This makes its representation as a Matrix Product Operator (MPO) and the representation of the joint {System + Environment} wave-function as a Matrix Product State (MPS) suited [orus_practical_2014][paeckel_timeevolution_2019].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The orthogonal polynomial-based chain mapping and the subsequent representation of the joint wave-function as a MPS (and the operators as MPO) are the building blocks of the Time-dependent Density operator with Orthonormal Polynomials Algorithm (TEDOPA) one of the state-of-the-art numerically exact method to simulate the dynamics of open quantum systems especially in the non-Markovian, non-perturbative regimes both at zero and finite temperatures [prior_efficient_2010][woods_simulating_2015][tamascelli_efficient_2019][dunnett_simulating_2021][lacroix_unveiling_2021].","category":"page"},{"location":"theory/#Finite-Temperature-with-T-TEDOPA","page":"Theoretical Background","title":"Finite Temperature with T-TEDOPA","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Assuming a unitary evolution for both the system and environment, the system's dynamics can be isolated by tracing out the environmental degrees of freedom. The density operator for the system at time t is described as","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"hatrho_S(t) = textTr_ElefthatU(t) hatrho_S(0) otimes hatrho_E(0) hatU^dagger(t)right","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Initially, the system state, hatrho_S(0), can be pure or mixed, and the environment is in a thermal state defined by the inverse temperature beta = (k_B T)^-1. This state is represented by a product of Gaussian states","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"hatrho_E(0) = bigotimes_omega frace^-beta omega hata_omega^dagger hata_omegaZ_omega(beta) ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The system's evolution is dictated by the environment's two-time correlation function S(t), which in turn is determined by the spectral density function J and the temperature beta via the Bose-Einstein distribution n_omega(beta)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"S(t) = int_0^infty domega J(omega)lefte^-iomega t(1 + n_omega(beta)) + e^iomega t n_omega(beta)right ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"To simulate finite temperature effects using a zero-temperature model with the T-TEDOPA method [tamascelli_efficient_2019], we extend the spectral density function to cover both positive and negative frequencies, allowing us to use a pure state description for the environment. This is achieved by defining a new spectral density function J(omega beta) that incorporates the Boltzmann factors, supporting the entire real axis","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"J(omega beta) = fractextsign(omega)J(leftomegaright)2 Big(1 + cothBig(fracbeta omega2Big)Big)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This modified bath has the same correlation function S(t) and thus allows us to maintain a pure state description of the environment, represented as a vacuum state, and avoid the computational complexities of density matrices","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"lefttextvacrightrangle = bigotimes_omega left0_omegarightrangle ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The Hamiltonian of the system interacting with this extended bath now includes temperature-dependent interactions:","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"hatH = hatH_S + int_-infty^+infty domega omega hata_omega^dagger hata_omega + hatA_S otimes int_-infty^+infty domega sqrtJ(omegabeta)left(hata_omega^dagger+hata_omegaright)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This method simplifies the simulation of finite temperature effects by treating them within an effective zero-temperature framework, thereby keeping the computational advantages of using pure states.","category":"page"},{"location":"theory/#Finite-temperature-with-the-thermofield-transformation","page":"Theoretical Background","title":"Finite temperature with the thermofield transformation","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Write about thermofield transfomation [devega_thermo_2015].","category":"page"},{"location":"theory/#Computation-of-the-chain-coefficients","page":"Theoretical Background","title":"Computation of the chain coefficients","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"A useful property of the orthonormal polynomials is that they obey a recurrence relation","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    P_n(omega) = (C_n-1omega - A_n-1)P_n-1(omega) + B_n-1P_n-2(omega) ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where A_n is related to the first moment of P_n, B_n and C_n to the norms of P_n and P_n-1[appel_mathematics_2007]. This recurrence relation can be used to construct the polynomials with the conditions that P_0(omega) = p_0^-1 = left(int_mathbbR^+ J(omega)mathrmdomega right)^-frac12 and P_-1(omega) = 0, with bullet the norm of bullet with respect to the measure J(omega), and P_n(omega) = p_n(omega)p_n^-1 ; where the polynomials p_n_ninmathbbN are the so called monic polynomials where the factor a_n in front of omega^n is equal to 1.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The energy of the chain mode n is given by varepsilon_n = A_n C_n^-1 and t_n=C_n^-1 is the coupling between mode n and n+1[chin_exact_2010].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The system couples only to the first mode with the coupling strength kappa = p_0.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Explain that for some weight function/SD they are known analytically and that for others we can use the build-in routines inspired by Gautschi or the PolyChaos.jl package.","category":"page"},{"location":"theory/#Tensor-Networks","page":"Theoretical Background","title":"Tensor Networks","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"A multipartite quantum state psirangle, e.g. a N-site system where the sites can each be in a state phi_irangle belonging to a d-dimensional Hilbert space, can be written as follows","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    psirangle = sum_i_kc_i_1ldots i_Nphi_i_1rangleotimesldotsotimesphi_i_Nrangle ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"where the complex numbers c_i_1ldots i_N are the amplitudes of each state phi_i_1rangleotimesldotsotimesphi_i_Nrangle whose superpositions form in full generality the state psirangle. Thus the state psirangle can be completely represented by a rank-N tensor c that is the collection of all possible amplitudes c_i_1ldots i_N. Here by the rank of a tensor, we simply mean the number of indices it has.","category":"page"},{"location":"theory/#MPS","page":"Theoretical Background","title":"MPS","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The tensor c of a quantum state psirangle corresponding to a one-dimensional system can be decomposed into a product of N smaller rank-3 tensors T_k (except for the first and last sites where the tensors will have a rank-2)","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    c_i_1ldots i_N = sum_alpha T^alpha_1_i_1T^alpha_1alpha_2 _i_2T^alpha_2alpha_3 _i_3ldots T^alpha_N-1_i_N  ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In this form, the local tensor T_k contains the information on the quantum state on site k and its relation (especially the entanglement) with the neighbouring sites.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The decomposition of the tensor of the amplitudes of a quantum state into a product of smaller rank tensors is called a Matrix Product State decomposition.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The contracted indices alpha_k between the tensors are called virtual indices and carry information about the correlations between bi-partitions of the state at bond k. The number of different values a virtual index can take is called the bond dimension and is denoted D. The free indices i_k associated with local quantum states are called physical indices. Thus, they can take d values (with d the dimension of the local Hilbert space).","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Any state in the Hilbert space of a one-dimensional many-body system can in principle be represented by a MPS by choosing a sufficiently large value for the bond dimension D [Orus]. On top of this intellectually satisfying property of MPSs being a dense set of states for a 1d-system, they can also be used as a practical Ans√§tze for a many-body quantum states by setting a maximal allowed value chi for the bond dimension D. In doing so, we restrict ourselves to a corner of the total Hilbert space. The rationale behind this Ansatz is the following: if the initial quantum state of a many-body system has a low bond dimension (typically if the initial state is a product state with D = 1), then in a finite time it will only be able to explore a region of the Hilbert space that is not to far away from its starting point. Thus, the bond dimension will not have the time to diverge exponentially [poulin_quantum_2011]. However, depending on the physical system at hand, this sub-manifold of the Hilbert space could still be \"too large\". There is an additional reason that explains why MPSs are good Ans√§tze for 1d physical systems. Most many-body Hamiltonians we (physicists) are interested in are local, meaning that the interactions they describe involve objects that are \"neighbours\". For such Hamiltonians, the ground states (outside of potential critical phases) follow the so called area law for the entanglement entropy [srednicki_entropy_1993][vidal_entanglement_2003][wolf_area_2008]. This law states that the entanglement entropy S_vN of a bi-partition of the system is proportional, not to the volume of the partition as one might expect, but to the hyper-surface of the partition's boundary; hence the name \"area law\". For a 3d system this corresponds to an actual surface area A, S_vN sim A; for a 2d system it corresponds to the length L of the partition's boundary, S_vN sim L; and in 1d the boundary reduces to a point, thus the entropy will be independent of the size of the system S_vN sim textconstant. The MPSs are states that satisfy this area law.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"An application of the Singular Value Decomposition is to create efficient approximations of quantum states to perform computations. The main idea is to reduce the content of the MPS to keep only the parts that contain the physics of interest. One method to realise this approximation is to do a SVD on each of the tensors of the MPS after each time step of the state time-evolution and to trim the smallest singular values in order to decrease the bond dimension of the MPS down to a chosen maximal value chi. The corresponding columns and rows of the unitary matrices U and V^dagger are also removed. Then, the trimmed matrices tildeU, tildeS and tildeV^dagger are contracted back to give an approximated tensor T with a smaller bond dimension. Another way to apply the restricted rank approximation is to restrict oneself into working in a manifold of fixed bond dimension D and to use methods that can enforce this constraint.","category":"page"},{"location":"theory/#MPO","page":"Theoretical Background","title":"MPO","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In order to compute expectation values of observables or apply unitary transformations to a quantum state, we need a TN representation of operators. In the same fashion as a one-dimensional quantum state can be represented as a MPS, operators acting on those states can be represented as Matrix Product Operators (MPO). For an operator hatO, its MPO can be defined as follows","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    hatO = sum_i_ki_k^ w W^i_1 i^_1_1 w_0w_1ldots  W^i_N i^_N_N w_N-1w_N phi_i_1^ldots phi_i_N^ranglelanglephi_i_1ldots phi_i_N ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The contracted indices between the tensors are called virtual indices. The free indices are called physical indices and correspond to the different input and output local quantum states.  They can take d values (with d the dimension of the local Hilbert space).","category":"page"},{"location":"theory/#TTN","page":"Theoretical Background","title":"TTN","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"A natural extension to the MPS is the (loop-free) tree tensor network.  A TTN is a generalisation of the MPS wherein each site, instead of being connected to only one other site to its right, may be connected to any arbitrary number of child sites. Provided the tree does not contain any loops, everything that one can do to an MPS/MPO can be extended straight-forwardly to TTN states and TTN operators.  The generalisation to trees introduces no new conceptual complexity (only implementational complexity). The sites of a TTN are usually referred to as nodes.  For our purposes, every node of a TTN state and operator has one parent leg, and any number (including zero) of child legs.  The first node is known as the head-node and has a dummy parent leg with dimension 1.","category":"page"},{"location":"theory/#Time-Dependent-Variational-Principal","page":"Theoretical Background","title":"Time-Dependent Variational Principal","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The original idea behind TDVP goes back to Dirac [dirac_note_1930] and Frenkel [frenkel_wave_1934]. The main point, in the modern tensor networks formulation, is that instead of solving the Schr√∂dinger equation and then truncating the MPS representation of the quantum state, one can solve the equations of motion projected into a space of restricted bond dimension [^haegemantime-dependent2011][haegeman_unifying_2016].","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The general formulation of the Dirac-Frenkel Variational Principle [raab_diracfrenkelmclachlan_2000] is that one looks for a solution varphirangle in mathcalM of the Schr√∂dinger equation where mathcalM subset mathcalH is a manifold of the total Hilbert space mathcalH in which we think that the relevant physical states `live'.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"We define T_varphiranglemathcalM the tangent space of mathcalM around the state varphirangle. The criterion to find varphirangle is that for every state chirangle in T_varphiranglemathcalM","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    langlechileft(fracmathrmdmathrmdt - frac1mathrmihbarhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"which can be interpreted as saying that the time evolution procedure should keep varphirangle inside of the manifold mathcalM.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The term variational in the name of the method comes from the fact that in practice one aims at minimising the right-hand side of the hereinabove Eq. to find varphirangle.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Introducing hatP_T_varphiranglemathcalM the projector onto the tangent space T_varphiranglemathcalM, we can write the state chirangle = hatP_T_varphiranglemathcalMphirangle with phirangle a state in mathcalH. Leading to","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    forall phirangle in mathcalH  langlephihatP_T_varphiranglemathcalMleft(fracmathrmdmathrmdt - frac1mathrmihbarhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"Because the time derivation and the projector commute, we have","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    forall phirangle in mathcalH  langlephileft(fracmathrmdmathrmdt - frac1mathrmihbarhatP_T_varphiranglemathcalMhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"This equation must be true for any phirangle in mathcalH, Eq.~(\\ref{eq:DiracFrenkel1}) can thus be written","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"    left(fracmathrmdmathrmdt - frac1mathrmihbarhatP_T_varphiranglemathcalMhatHright)varphirangle =0 ","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"In the context of MPS, the manifold mathcalM will correspond to the space of full-ranked MPS of a given bond dimension D, and the tangent space will be the space spanned by variations of single MPS tensors.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"The major advantage of this method is that it naturally preserves the unitarity of the time evolution and conserves the energy.","category":"page"},{"location":"theory/#Bibliography","page":"Theoretical Background","title":"Bibliography","text":"","category":"section"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[chin_exact_2010]: Chin, A. W.; Rivas, √Å.; Huelga, S. F.; Plenio, M. B. Exact Mapping between System-Reservoir Quantum Models and Semi-Infinite Discrete Chains Using Orthogonal Polynomials. Journal of Mathematical Physics 2010, 51 (9), 092109. https://doi.org/10.1063/1.3490188.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[chin_role_2013]: Chin, A. W.; Prior, J.; Rosenbach, R.; Caycedo-Soler, F.; Huelga, S. F.; Plenio, M. B. The Role of Non-Equilibrium Vibrational Structures in Electronic Coherence and Recoherence in Pigment‚ÄìProtein Complexes. Nature Phys 2013, 9 (2), 113‚Äì118. https://doi.org/10.1038/nphys2515.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[alvertis_nonequilibrium_2019]: Alvertis, A. M.; Schr√∂der, F. A. Y. N.; Chin, A. W. Non-Equilibrium Relaxation of Hot States in Organic Semiconductors: Impact of Mode-Selective Excitation on Charge Transfer. J. Chem. Phys. 2019, 151 (8), 084104. https://doi.org/10.1063/1.5115239.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dunnett_influence_2021]: Dunnett, A. J.; Gowland, D.; Isborn, C. M.; Chin, A. W.; Zuehlsdorff, T. J. Influence of Non-Adiabatic Effects on Linear Absorption Spectra in the Condensed Phase: Methylene Blue. J. Chem. Phys. 2021, 155 (14), 144112. https://doi.org/10.1063/5.0062950.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[caycedosoler_exact_2022]: Caycedo-Soler, F.; Mattioni, A.; Lim, J.; Renger, T.; Huelga, S. F.; Plenio, M. B. Exact Simulation of Pigment-Protein Complexes Unveils Vibronic Renormalization of Electronic Parameters in Ultrafast Spectroscopy. Nat Commun 2022, 13 (1), 2912. https://doi.org/10.1038/s41467-022-30565-4.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[orus_practical_2014]: Orus, R. A Practical Introduction to Tensor Networks: Matrix Product States and Projected Entangled Pair States. Annals of Physics 2014, 349, 117‚Äì158. https://doi.org/10.1016/j.aop.2014.06.013.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[paeckel_timeevolution_2019]: Paeckel, S.; K√∂hler, T.; Swoboda, A.; Manmana, S. R.; Schollw√∂ck, U.; Hubig, C. Time-Evolution Methods for Matrix-Product States. Annals of Physics 2019, 411, 167998. https://doi.org/10.1016/j.aop.2019.167998.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[prior_efficient_2010]: Prior, J.; Chin, A. W.; Huelga, S. F.; Plenio, M. B. Efficient Simulation of Strong System-Environment Interactions. Phys. Rev. Lett. 2010, 105 (5), 050404. https://doi.org/10.1103/PhysRevLett.105.050404.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[woods_simulating_2015]: Woods, M. P.; Cramer, M.; Plenio, M. B. Simulating Bosonic Baths with Error Bars. Phys. Rev. Lett. 2015, 115 (13), 130401. https://doi.org/10.1103/PhysRevLett.115.130401.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[tamascelli_efficient_2019]: Tamascelli, D.; Smirne, A.; Lim, J.; Huelga, S. F.; Plenio, M. B. Efficient Simulation of Finite-Temperature Open Quantum Systems. Phys. Rev. Lett. 2019, 123 (9), 090402. https://doi.org/10.1103/PhysRevLett.123.090402.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dunnett_simulating_2021]: Dunnett, A. J.; Chin, A. W. Simulating Quantum Vibronic Dynamics at Finite Temperatures With Many Body Wave Functions at 0 K. Front. Chem. 2021, 8. https://doi.org/10.3389/fchem.2020.600731.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[lacroix_unveiling_2021]: Lacroix, T.; Dunnett, A.; Gribben, D.; Lovett, B. W.; Chin, A. Unveiling Non-Markovian Spacetime Signaling in Open Quantum Systems with Long-Range Tensor Network Dynamics. Phys. Rev. A 2021, 104 (5), 052204. https://doi.org/10.1103/PhysRevA.104.052204.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[appel_mathematics_2007]: Appel, W. Mathematics for Physics and Physicists; Princeton University Press, 2007.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[devega_thermo_2015]: de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[Orus]: Orus, R. A Practical Introduction to Tensor Networks: Matrix Product States and Projected Entangled Pair States. Annals of Physics 2014, 349, 117‚Äì158. https://doi.org/10.1016/j.aop.2014.06.013.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[poulin_quantum_2011]: Poulin, D.; Qarry, A.; Somma, R.; Verstraete, F. Quantum Simulation of Time-Dependent Hamiltonians and the Convenient Illusion of Hilbert Space. Phys. Rev. Lett. 2011, 106 (17), 170501. https://doi.org/10.1103/PhysRevLett.106.170501.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[srednicki_entropy_1993]: Srednicki, M. Entropy and Area. Phys. Rev. Lett. 1993, 71 (5), 666‚Äì669. https://doi.org/10.1103/PhysRevLett.71.666.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[vidal_entanglement_2003]: Vidal, G.; Latorre, J. I.; Rico, E.; Kitaev, A. Entanglement in Quantum Critical Phenomena. Phys. Rev. Lett. 2003, 90 (22), 227902. https://doi.org/10.1103/PhysRevLett.90.227902.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[wolf_area_2008]: Wolf, M. M.; Verstraete, F.; Hastings, M. B.; Cirac, J. I. Area Laws in Quantum Systems: Mutual Information and Correlations. Phys. Rev. Lett. 2008, 100 (7), 070502. https://doi.org/10.1103/PhysRevLett.100.070502.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[dirac_note_1930]: Dirac, P. A. M. Note on Exchange Phenomena in the Thomas Atom. Mathematical Proceedings of the Cambridge Philosophical Society 1930, 26 (3), 376‚Äì385. https://doi.org/10.1017/S0305004100016108.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[frenkel_wave_1934]: Frenkel, Y. Wave Mechanics, Advanced General Theory; Oxford, 1934; Vol. 1.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[^haegemantime-dependent2011]:     > Haegeman, J.; Cirac, J. I.; Osborne, T. J.; Pi≈æorn, I.; Verschelde, H.; Verstraete, F. Time-Dependent Variational Principle for Quantum Lattices. Phys. Rev. Lett. 2011, 107 (7), 070601. https://doi.org/10.1103/PhysRevLett.107.070601.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[haegeman_unifying_2016]: Haegeman, J.; Lubich, C.; Oseledets, I.; Vandereycken, B.; Verstraete, F. Unifying Time Evolution and Optimization with Matrix Product States. Phys. Rev. B 2016, 94 (16), 165116. https://doi.org/10.1103/PhysRevB.94.165116.","category":"page"},{"location":"theory/","page":"Theoretical Background","title":"Theoretical Background","text":"[raab_diracfrenkelmclachlan_2000]: Raab, A. On the Dirac‚ÄìFrenkel/McLachlan Variational Principle. Chemical Physics Letters 2000, 319 (5), 674‚Äì678. https://doi.org/10.1016/S0009-2614(00)00200-1.","category":"page"},{"location":"user-guide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Here we explain the different steps to perform a simulation.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Examples with detailed explanations can be found in Examples.","category":"page"},{"location":"user-guide/#Initial-State","page":"User Guide","title":"Initial State","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The initial many-body state of the {System + Environment} can be described easily as Matrix Product States (MPS) or Tree Tensor Networks (TTN) state (e.g. when a system is coupled to several environments).","category":"page"},{"location":"user-guide/#Matrix-Product-States","page":"User Guide","title":"Matrix Product States","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"A MPS can be initialized with several methods.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The productstatemps method enables  to instantiate arbitrary MPS of fixed uniform bond dimension with non-uniform physical dimensions. The individual states of the MPS sites can be provided by setting state to a list of column vectors.  Setting state=:Vacuum will produce an MPS in the vacuum state.  Setting state=:FullOccupy will produce an MPS in which each site is fully occupied. The gauge of the MPS can also be set using a keyword argument.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"julia> œà = unitcol(1,2) # system initial state\n\njulia> d = 6; N = 30; Œ± = 0.1; Œî = 0.0; œâ0 = 0.2; s = 1 \n\njulia> cpars = chaincoeffs_ohmic(N, Œ±, s) # chain coefficient for an Ohmic spectral density\n\njulia> H = spinbosonmpo(œâ0, Œî, d, N, cpars)\n\njulia> A = productstatemps(physdims(H), state=[œà, fill(unitcol(1,d), N)...]) # MPS representation of |œà>|Vacuum>","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Alternatively, a chain with a specified number of excitation localised on one site, or delocalized accross several sites can be generated with MPSDynamics.chainmps.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Random MPS can also be generated with the randmps method.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"For the case of fermionic states (which need to be anti-symmetrized), the MPSDynamics.electronkmps method generate an MPS for an electron with momentum k, and the MPSDynamics.electron2kmps generate an MPS with 2 electrons in k-states k1 and k2.","category":"page"},{"location":"user-guide/#Tree-Tensor-Networks","page":"User Guide","title":"Tree Tensor Networks","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Write a quick explanation of the how trees are structured: parents, child, nodes; and that most methods to initialize a MPS are overloaded for TreeNetwork. ","category":"page"},{"location":"user-guide/#Hamiltonian","page":"User Guide","title":"Hamiltonian","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"In order to perform time evolution and have access to the dynamics of the many-body state a Hamiltonian needs to be specified in the form of a Matrix Product Operator (MPO) of as a tree tensor network. Either way, this can be done by using a Build-in Hamiltonian, Convert a MPO from ITensor, or creating a Tailored MPO.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"In the context of Open Quantum Systems, custom chain coefficients for the environment can be generated for finite temperature simulations, and/or user provided spectral densities (SDs).","category":"page"},{"location":"user-guide/#Build-in-Hamiltonian","page":"User Guide","title":"Build-in Hamiltonian","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"MPSDynamics provides several topical Hamiltonians directly in the form of MPO or Tree Tensor Networks such as the Ising model MPSDynamics.isingmpo, the XYZ Hamiltonian MPSDynamics.xyzmpo, the Spin Boson Model MPSDynamics.spinbosonmpo, a spin coupled to two bosonic baths MPSDynamics.twobathspinmpo, nearest neighbour interactions Hamiltonian MPSDynamics.nearestneighbourmpo, the independent boson model MPSDynamics.ibmmpo, (non-)uniform tight-binding chain Hamiltonian MPSDynamics.tightbindingmpo.","category":"page"},{"location":"user-guide/#Convert-a-MPO-from-ITensor","page":"User Guide","title":"Convert a MPO from ITensor","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The method MPSDynamics.MPOtoVector converts an ITensors chain MPO into a form compatible with MPSDynamics.","category":"page"},{"location":"user-guide/#Tailored-MPO","page":"User Guide","title":"Tailored MPO","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"One can also construct MPO tailored to the problem one is interested in. MPOs are fundamentally a lists of rank-4 tensors such that the right bond dimension of the nth tensor must be equal to the left bond dimension of the n+1th tensor; and the dimension of the physical bonds of the nth tensor must be equal to the corresponding physical bond on the MPS.","category":"page"},{"location":"user-guide/#Finite-Temperature-and-Custom-SD","page":"User Guide","title":"Finite Temperature and Custom SD","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"In the T-TEDOPA framework (see Theoretical Background for more details) finite temperature simulations are done with an effective pure state description of the system and the environment where the coupling coefficients (or the SD) is temperature-dependent.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The corresponding chain coefficients for an Ohmic or a user provided spectral density (that can thus in pratice be either at zero or finite temperature) are computed with the [chaincoeffs_finiteT](@ref). This method is based on the ORTHOPOL routines[Gautschi]","category":"page"},{"location":"user-guide/#Observables","page":"User Guide","title":"Observables","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"System and environment observables can be computed, as well as system-and-environment 'non-local' observables.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Observables that will be passed to MPSDynamics.runsim(@ref) to have their expectation value computated at each time step are defined with the OneSiteObservable and [TwoSiteObservable](@ref).","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"One-site and two-site obsevables work similarly, they need to be given a name, an (pair of) operator(s) and the (list of) site(s) on which they are evaluated.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"For instance one can calculated the average number of excitation in each of the N environmental modes","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"    ob = OneSiteObservable(\"chain mode occupation\", numb(d), (2,N+1))","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"It is also possible to measure composite system/environment observables, for example","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"    ob = TwoSiteObservable(\"SXdisp\", sx, disp(d), [1], collect(2:N+1))","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"which measure the correlation between the spin in the x-direction and the displacement of the bath modes.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Purely environmental 'non-local' observables such as ","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"    ob = TwoSiteObservable(\"bath coherence\", crea(d), anih(d), collect(2:N+1), collect(2:N+1))","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"that computes all the chain mode coherences langlehata_n^daggerhata_mrangle (and the chain mode occupation when n = m).","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"We note that if one knows the coherences and populations of all the chain modes, it is then possible to reconstruct the populations of the normal mode environment.","category":"page"},{"location":"user-guide/#Time-Evolution","page":"User Guide","title":"Time-Evolution","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Explain that we do TDVP.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"A simulation is runned by the MPSDynamics.runsim(@ref) function.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Local one-site and two-site observables, as well as non-local two-site observables, can be efficiently computed for each time-step of the time-evolution.","category":"page"},{"location":"user-guide/#One-site-TDVP","page":"User Guide","title":"One-site TDVP","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Fixed bond dimension, complexity XXX, preserves unitarity.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The convergence parameter is the bond dimension.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Is set in MPSDynamics.runsim(@ref) usind the key word argument method=:TDVP1","category":"page"},{"location":"user-guide/#Two-Site-TDVP","page":"User Guide","title":"Two-Site TDVP","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Varying bond dimension, complexity higher than 1TDVP, but breaks unitarity because of a SVD.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The convergence parameter is the threshold of the SVD.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Is set in MPSDynamics.runsim(@ref) usind the key word argument method=:TDVP2","category":"page"},{"location":"user-guide/#Adaptive-One-Site-TDVP","page":"User Guide","title":"Adaptive One-Site TDVP","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Keeps the good scaling of the 1TDVP, preserves unitarity but is able to increase the bond dimendion.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The convergence parameter is a threshold value for the rate of change of the projection error with respect to the bond dimension.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Is set in MPSDynamics.runsim(@ref) usind the key word argument method=:DTDVP","category":"page"},{"location":"user-guide/#Data-Storage","page":"User Guide","title":"Data Storage","text":"","category":"section"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The data (i.e. observables time-series) is stored in the JLD format which is based on HDF5.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The HDF5 format is natively supported across many platforms and languages (e.g. Python, or Mathematica).","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"For the data to be saved to a file after a run, the keyword argument save=true needs to be used in runsim.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"The directory where the data should be saved can be chosen by setting a path with the savedir keyword argument.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"A plot keyword argument can also be used to choose whether plots for 1D observables will be automatically generated and saved along with the data. ","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"Loading the data in Julia using the JLD.jl package will recover the full type information of the Julia variables that were stored.","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"julia> using JLD\n\njulia> dat = load(\"filename.jld\")\nDict{String, Any} with 2 entries:\n  \"parameters\" => Dict{String, Any}(\"tmax\"=>0.2, \"method\"=>:DTDVP, \"dt\"=>0.0005‚Ä¶\n  \"data\"       => Dict{String, Any}(\"bonddims\"=>[1 1 ‚Ä¶ 1 1; 1 2 ‚Ä¶ 2 2; ‚Ä¶ ; 1 1 ‚Ä¶","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"If the data is loaded in an variable dat the structure is the folowing:","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"the parameters entry contains a dictionary where all the simulation parameters are stored\nthe data entry contains a dictionary where are stored simulation time, the observables and (whenever relevent) the bond dimension of the state at each time steps. ","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"julia> dat[\"parameters\"]\nDict{String, Any} with 11 entries:\n  \"tmax\"       => 0.2\n  \"method\"     => :DTDVP\n  \"dt\"         => 0.0005\n  \"name\"       => \"my model\"\n  \"Œî\"          => 0.0\n  \"Œ≤\"          => 0.0186854\n  \"N\"          => 300.0\n  \"d\"          => 15.0\n  \"unid\"       => \"Ovzm6\"\n  \"œâ0\"         => 0.0\n  \"convparams\" => 0.0005\n\njulia> dat[\"data\"]\nDict{String, Any} with 6 entries:\n  \"bonddims\" => [1 1 ‚Ä¶ 1 1; 1 2 ‚Ä¶ 2 2; ‚Ä¶ ; 1 1 ‚Ä¶ 7 7; 1 1 ‚Ä¶ 1 1]\n  \"sx\"       => [1.0, 0.912818, 0.741759, 0.605797, 0.528792, 0.492497, 0.47976‚Ä¶\n  \"sz\"       => [0.0, 0.0871825, 0.25824, 0.394201, 0.471207, 0.507503, 0.52023‚Ä¶\n  \"nchain\"   => [0.0 0.23466 ‚Ä¶ 1.84319 1.76098; 0.0 0.00231507 ‚Ä¶ 0.83105 0.9033‚Ä¶\n  \"sy\"       => [0.0, -0.0133489, -0.0588887, -0.0858181, -0.0759996, -0.048539‚Ä¶\n  \"times\"    => [0.0, 0.0005, 0.001, 0.0015, 0.002, 0.0025, 0.003, 0.0035, 0.00‚Ä¶\n","category":"page"},{"location":"user-guide/","page":"User Guide","title":"User Guide","text":"[Gautschi]: Gautschi, W. Algorithm 726: ORTHPOL‚Äìa package of routines for generating orthogonal polynomials and Gauss-type quadrature rules. ACM Trans. Math. Softw. 20, 21‚Äì62 (1994).","category":"page"},{"location":"examples/timedep/#Time-dependent-Hamiltonian","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"","category":"section"},{"location":"examples/timedep/#Context","page":"Time-dependent Hamiltonian","title":"Context","text":"","category":"section"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"To simulate a drive or a laser pulse, a time-dependent Hamiltonian is often needed. Here we explain thanks to the script in MPSDynamics/examples/sbm_Htimedependent.jl how this type of Hamiltonian can be integrated within the method and applied on a wavefunction. We will take a Spin-Boson Model (SBM) Hamiltonian with an Ohmic spectral density. However, the time-dependency is not model specific and can be adapated for other models. For more information about the SBM, see the dedicated example. For this example, we simulate a drive of the form","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"        hatH_textdrive(t) = epsilon hatsigma_x sin(omega_textdrive t)","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"with epsilon = frac2 piT_textRabi the amplitude of the drive, T_textRabi the Rabi period, and omega_textdrive the frequency of the drive. The drive is set up to be on resonance with the two-level system.","category":"page"},{"location":"examples/timedep/#The-code","page":"Time-dependent Hamiltonian","title":"The code","text":"","category":"section"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"First we load the MPSdynamics.jl package to be able to perform the simulation, the Plots.jl one to plot the results, and the LaTeXStrings.jl one to be able to use LaTeX in the plots. The function MPSDynamics.disp is also imported.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"using MPSDynamics, Plots, LaTeXStrings\n\nimport MPSDynamics: disp","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"We then define variables for the physical parameters of the simulation. Among these, three are convergence parameters:","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"d is the number of states we retain for the truncated harmonic oscillators representation of environmental modes\nN is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"The variable Ndrive represents the site of the MPO where the operator of the time-dependent part acts. For this example, the two-level system is at the first site of the MPS. ","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#----------------------------\n# Physical parameters\n#----------------------------\n\nd = 4 # number of Fock states of the chain modes\n\nN = 60 # length of the chain\n\nŒ± = 0.005 # coupling strength\n\nŒî = 0.0 # tunneling \n\nœâ0 = 0.8 # TLS gap\n\ns = 1 # ohmicity\n\ncpars = chaincoeffs_ohmic(N, Œ±, s) # chain parameters, i.e. on-site energies œµ_i, hopping energies t_i, and system-chain coupling c_0\n\nTrabi = 30.0 # Rabi period of the drive\n\nœµ = 2*pi / Trabi # Intensity of the drive\n\nœâdrive = œâ0 # Frequency of the drive\n\nNdrive = 1 #Number of the site on which the drive is applied","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is mathcalO(dt^3). In this example we present only one-site implementation of TDVP that preserves the unitarity of the evolution:","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"the regular one-site method with the keyword :TDVP1 where all the virtual bonds of the MPS have the same bond dimension D","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"Logically the constant bond dimension of the MPS for TDVP1 is the respective convergence parameter.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#-----------------------\n# Simulation parameters\n#-----------------------\n\ndt = 0.5 # time step\n\ntfinal = 100.0 # simulation time\n\nmethod = :TDVP1 # time-evolution method\n\nD = [6] # MPS bond dimension","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"Using MPSDynamics.jl built-in methods we define the SBM MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the 'local state' of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"In this part, the time-dependent terms of the MPO are stored in a list. This enables to add these terms to the MPO elements at each timestep and avoid the calculation of an entire new MPO. This way is not cumbersome since it adds a matrix sum at each time step.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#---------------------------\n# MPO and initial state MPS\n#---------------------------\n\ntimelist = collect(0:dt:tfinal)\nnumsteps = length(timelist)-1\n\nHt = [œµ*sx*sin(œâdrive*tstep) for tstep in timelist] # Time-dependent Hamiltonian term\n\nH = spinbosonmpo(œâ0, Œî, d, N, cpars) # MPO representation of the Hamiltonian\n\nœà = unitcol(2,2) # Initial down-z system state \n\nA = productstatemps(physdims(H), state=[œà, fill(unitcol(1,d), N)...]) # MPS representation of |œà>|Vacuum>","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"We then choose the observables that will be stored in the data and the MPSDynamics.runsim arguments.","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#---------------------------\n# Definition of observables\n#---------------------------\n\nob1 = OneSiteObservable(\"sz\", sz, 1)\n\nob2 = OneSiteObservable(\"chain mode occupation\", numb(d), (2,N+1))\n\nob3 = TwoSiteObservable(\"SXdisp\", sx, disp(d), [1], collect(2:N+1))\n","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"MPSDynamics.runsim is called to perform the dynamics. The argument timedep is set up to true and Ndrive and Htime are provided in the kwargs. ","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"#-------------\n# Simulation\n#------------\n\nA, dat = runsim(dt, tfinal, A, H;\n                name = \"Driving field on ohmic spin boson model\",\n                method = method,\n                obs = [ob1],\n                convobs = [ob1],\n                params = @LogParams(N, d, Œ±, Œî, œâ0, s),\n                convparams = D,\n                timedep = true, # the Hamiltonian is time dependent\n                Ndrive = Ndrive, # the first site of the MPS/MPO (i.e. the system) is concerned\n                Htime = Ht, # list of time-dependent terms\n                verbose = false,\n                save = true,\n                plot = true,\n                );","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"Eventually, the stored observables can be represented","category":"page"},{"location":"examples/timedep/","page":"Time-dependent Hamiltonian","title":"Time-dependent Hamiltonian","text":"\n#----------\n# Plots\n#----------\n\nplot(dat[\"data/times\"], dat[\"data/sz\"], label=\"Dmax = $(D...)\", xlabel=L\"t\",ylabel=L\"\\sigma_z\", title=\"\")","category":"page"},{"location":"examples/anderson-model/#The-Anderson-Impurity-Model","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"In these two examples, we use the fermionic chain mapping proposed in [khon_efficient_2021] to perform tensor network simulations of the Single Impurity Anderson Model (SIAM). The SIAM Hamiltonian is defined as: $     \\hat H^\\text{SIAM}  = \\hat H\\text{loc} + \\hat H\\text{hyb} + \\hat H\\text{cond} = \\overbrace{\\epsilond \\hat d^\\dagger \\hat d}^{\\hat H\\text{loc}} + \\underbrace{\\sum{k} Vk \\Big( \\hat d^\\dagger \\hat ck + \\hat ck^\\dagger \\hat d \\Big)}{H\\text{hyb}} + \\underbrace{\\sumk \\epsilonk \\hat ck^\\dagger \\hat ck}{H_I^\\text{chain}}. $","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"All of the operators obey to the usual fermionic anti-commutation relations: hat c_i hat c_j^dagger  = delta_ij, hat c_i hat c_j  =hat c_i^dagger hat c_j^dagger  =0 forall ij. The chain mapping is based on a thermofield-like transformation [2], performed with fermions: ancillary fermionic operators hat c_2k are defined, one for each of the original fermionic modes hat c_1k. A Bogoliubov transformation is then applied, so that two new fermionic modes hat f_1k and hat f_2k are defined as a linear combination of hat c_1k and hat c_2k. Two chains are defined: the chain labelled 1 for the empty modes, the chain labelled 2 for the filled modes. The following relations are used to define the functions equivalent to the spectral density of the bosonic case, one for each chain: $ \\begin{split}    &V{1k} = V{k} \\sin \\thetak = \\sqrt{\\frac{1}{e^{\\beta \\epsilonk}+1}} \\\n   &V{2k} = V{k} \\cos \\thetak = \\sqrt{\\frac{1}{e^{-\\beta \\epsilonk}+1}},  \\end{split} $     where we choose the spectral function that characterizes the fermionic bath to be: V_k= sqrt1-k^2, and we define the dispersion relation as: e_k = k, that is, a linear dispersion relation with propagation speed equal to 1. This latter choice corresponds to a model of metals (gapless energy spectrum). We select a filled state as the initial state of the defect. Using the mapping proposed in [khon_efficient_2021], the chain Hamiltonian becomes: $     \\begin{split}     \\hat H^\\text{chain}  = \\hat H\\text{loc} &+ \\sum{i = {1,2}}\\bigg[ J{i,0} \\Big(\\hat d^\\dagger \\hat a{i,0} + \\hat d \\hat a{i,0}^\\dagger \\Big) + \\ &+ \\sum{n=1}^\\infty  \\Big( J{i,n} \\hat a{i,n}^\\dagger \\hat a{i,n-1} +  J{i,n} \\hat  a{i,n-1}^\\dagger \\hat a{i,n} \\Big) + \\sum{n=0}^\\infty E{i,n} \\hat  a{i,n}^\\dagger \\hat a{i,n} \\bigg],     \\end{split} $ where the J_in coefficients are the couplings between the chain sites and the E_in coefficients are the energies associated to each chain site. Clearly, the interactions are between nearest neighbors. This, combined with the fact that the fermions in our model are spinless, enables a straightforward mapping into fermionic operators of the bosonic creation and annihilation operators, that on their part obey to the bosonic commutation relations: hat b_i hat b_j^dagger = delta_ij, hat b_i hat b_j =hat b_i^dagger hat b_j^dagger =0 forall ij. The mapping derived from Jordan-Wigner transformations for spinless fermions is: $     \\hat a{i}^\\dagger \\hat a{i+1} + \\hat a{i+1}^\\dagger \\hat a{i} = \\hat b{i}^\\dagger \\hat b{i+1} + \\hat b{i+1}^\\dagger \\hat b{i}.   $","category":"page"},{"location":"examples/anderson-model/#Double-chain-mapping","page":"The Anderson Impurity Model","title":"Double chain mapping","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The corresponding MPO representation is: $ \\begin{split} & \\begin{bmatrix}  \\hat{\\mathbb I} & J{2,N} \\hat b{2,N}^\\dagger & J{2,N} \\hat b{2,N} & E{2,N} \\hat b{2,N}^\\dagger \\hat b{2,N}  \\end{bmatrix}\\cdot ... \\cdot \\begin{bmatrix}  \\hat{ \\mathbb I} & J{2,0} \\hat b{2,0}^\\dagger & J{2,0} \\hat b{2,0} & E{2,0} \\hat b{2,0}^\\dagger \\hat b{2,0}\\\n0 &0 & 0 & \\hat b{2,0} \\\n0 &0 & 0 & \\hat b{2,0}^\\dagger \\\n0 &0 & 0 & \\hat{\\mathbb I} \\end{bmatrix} \\cdot \\ \\cdot & \\begin{bmatrix}  \\hat{ \\mathbb I} & \\hat d^\\dagger & \\hat d & \\epsilond \\hat d^\\dagger \\hat d\\\n0 &0 & 0 & \\hat d \\\n0 &0 & 0 & \\hat d^\\dagger \\\n0 &0 & 0 & \\hat{\\mathbb I} \\end{bmatrix} \\cdot  \\begin{bmatrix}  \\hat{ \\mathbb I} & \\hat b{1,0}^\\dagger & \\hat b{1,0} & E{1,0} \\hat b{1,0}^\\dagger \\hat b{1,0}\\\n0 &0 & 0 & \\hat J{1,0}b{1,0} \\\n0 &0 & 0 & \\hat J{1,0}b{1,0}^\\dagger \\\n0 &0 & 0 & \\hat{\\mathbb I} \\end{bmatrix} \\cdot  ... \\cdot \\begin{bmatrix}  E{2,N} \\hat b{2,N}^\\dagger \\hat b{2,N} \\ J{2,N} \\hat b{2,N} \\ J{2,N} \\hat b_{2,N}^\\dagger \\ \\hat{\\mathbb I} \\end{bmatrix} \\end{split} $","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The system starts from a filled state, the chain starts as in the Fermi sea.","category":"page"},{"location":"examples/anderson-model/#Interleaved-chain-mapping","page":"The Anderson Impurity Model","title":"Interleaved chain mapping","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"The drawback of such a representation though, is that the particle-hole pairs are spatially separated in the MPS, creating correlations and therefore leading to a dramatic increase in the bond dimensions. This is why Kohn and Santoro propose an interleaved geometry, the advantages of which are thoroughly explained in \\cite{KohnSantoro2021b}. Exploiting the interleaved representation, the interaction comes to be between next-nearest neighbors: a string operator appears in the Jordan-Wigner transformation from bosons to fermions: $     \\hat a{i}^\\dagger \\hat a{i+2} + \\hat a{i+2}^\\dagger \\hat a{i} = \\hat b{i}^\\dagger \\hat F{i+1} \\hat b{i+2} + \\hat b{i} \\hat F{i+1} \\hat b{i+2}^\\dagger, $ where the string operator hat F_i is defined as: \\hat Fi = (-1)^{\\hat ni} = \\hat{\\mathbb I} -2 \\hat ni = \\hat{\\mathbb I}-2 \\hat bi^\\dagger \\hat bi. It is possible to find the analytical form also for MPOs with long range interaction \\cite{mpo}. In the case of next-nearest neighbors interactions between spinless fermions, the MPO representation will require a bond dimension $\\chi=6. We explicitly write it as: $ \\begin{split} & \\begin{bmatrix}  \\hat{\\mathbb I} & \\hat d & \\hat d^\\dagger & 0 & 0 & E{d} \\hat d^\\dagger \\hat d  \\end{bmatrix}\\cdot \\begin{bmatrix}  \\hat{ \\mathbb I} & \\hat b{2,0} & \\hat b{2,0}^\\dagger & 0 & 0 & E{2,0} \\hat b{2,0}^\\dagger \\hat b{2,0}\\\n0 &0 & 0 & \\hat{F}{2,0} & 0 & J{2,0} \\hat b{2,0}^\\dagger \\\n0 &0 & 0 & 0 & \\hat{F}{2,0} & J{2,0} \\hat b{2,0} \\\n0 &0 & 0 & 0 & 0 &  0\\\n0 &0 & 0 & 0 & 0 & 0 \\\n0 &0 & 0 & 0 & 0 & \\hat{\\mathbb I} \\end{bmatrix} \\cdot \\ \\cdot & \\begin{bmatrix}  \\hat{ \\mathbb I} & \\hat b{1,0} & \\hat b{1,0}^\\dagger & 0 & 0 & E{1,0} \\hat b{1,0}^\\dagger \\hat b{1,0}\\\n0 &0 & 0 & \\hat{ F}{1,0} & 0 & 0 \\\n0 &0 & 0 & 0 & \\hat{F}{1,0} & 0 \\\n0 &0 & 0 & 0 & 0 & J{1,0} \\hat b{1,0}^\\dagger \\\n0 &0 & 0 & 0 & 0 & J{1,0} \\hat b{1,0} \\\n0 &0 & 0 & 0 & 0 & \\hat{\\mathbb I} \\end{bmatrix} \\cdot ... \\cdot  \\begin{bmatrix}  \\hat{ \\mathbb I} & \\hat b{2,N} & \\hat b{2,N}^\\dagger & 0 & 0 & E{2,N} \\hat b{2,N}^\\dagger \\hat b{2,N}\\\n0 &0 & 0 & \\hat{F}{2,N} & 0 & 0 \\\n0 &0 & 0 & 0 & \\hat{F}{2,N} & 0 \\\n0 &0 & 0 & 0 & 0 & J{2,N} \\hat b{2,N}^\\dagger \\\n0 &0 & 0 & 0 & 0 & J{2,N} \\hat b{2,N} \\\n0 &0 & 0 & 0 & 0 & \\hat{\\mathbb I} \\end{bmatrix} \\cdot \\ \\cdot & \\begin{bmatrix}  E{1,N} \\hat b{1,N}^\\dagger \\hat b{1,N} \\ 0 \\0 \\ J{1,N} \\hat b{1,N}^\\dagger \\ J{1,N} \\hat b{1,N} \\ \\hat{\\mathbb I} \\end{bmatrix}  \\end{split} $ ________________","category":"page"},{"location":"examples/anderson-model/#References","page":"The Anderson Impurity Model","title":"References","text":"","category":"section"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"[khon_efficient_2021]: Kohn, L.; Santoro, G. E. Efficient mapping for anderson impurity problems with matrix product states. Phys. Rev. B 2021, 104 (1), 014303. https://doi.org/10.1103/PhysRevB.104.014303.","category":"page"},{"location":"examples/anderson-model/","page":"The Anderson Impurity Model","title":"The Anderson Impurity Model","text":"[devega_thermo_2015]: de Vega, I.; Banuls, M-.C. Thermofield-based chain-mapping approach for open quantum systems. Phys. Rev. A 2015, 92 (5), 052116. https://doi.org/10.1103/PhysRevA.92.052116.","category":"page"},{"location":"examples/puredephasing/#Pure-Dephasing","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"","category":"section"},{"location":"examples/puredephasing/#Context","page":"Pure-Dephasing","title":"Context","text":"","category":"section"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The Pure-Dephasing Model describes a two-level system interacting linearly with an environment characterised by a spectral density (SD) J(omega). The coupling only acts on diagonal terms through the sigma_z operator. The Hamiltonian reads","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"        hatH = fracomega_02hatsigma_z + int_0^+inftyomega hata^dagger_omegahata_omega mathrmdomega + frachatsigma_z2int_0^+inftysqrtJ(omega)(hata_omega + hata^dagger_omega)mathrmdomega","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Although this interaction will not change the population of the two-level system, the coherences between the two states will vary due to the environment. Introducing the two-level system reduced density matrix rho_ij(t) with ij in (01), the diagonal terms rho_ii(t) are the populations of the states and the anti-diagonal terms rho_ij(t) with i neq j are the coherences between the two states. The effect of the sigma_z bath interaction is to decouple the two states 0rangle and 1rangle. ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The density matrix can be calculated within the MPS formalism with the MPO psirangle langle psi. Tracing out the environment leads to the reduced density matrix. This can be done with the function MPSDynamics.rhoreduced_1site. ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"An analytical formula can be found for the decoherence function Gamma(t), taking into account the SD as well as the temperature of the environment [breuer]","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"    Gamma(t) = - int_0^omega_c mathrmd omega J(omega)frac(1 - cos(omega t))omega^2 coth(Œ≤omega2) ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"with beta = (k_B T)^-1. For the case where beta longrightarrow infty, the integral reads","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"    Gamma(t) = - int_0^omega_c mathrmd omega J(omega)frac(1 - cos(omega t))omega^2 ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The time-dependent anti-diagonal terms of the reduced density matrix are then expressed as","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"    rho_12(t) = rho_21(t)^* =rho_12(0) exp(Gamma(t)) ","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Setting up the initial two-level system as a cat state psirangle_S(0) = frac0rangle pm 1ranglesqrt2, this leads to rho_12(0)=frac12.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Here we break out and comment the script in MPSDynamics/examples/puredephasing.jl and MPSDynamics/examples/puredephasing_temperature.jl to show how to simulate this model with an Ohmic SD (hard cut-off) using the T-TEDOPA method as implemented in MPSDynamics.jl.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The T-TEDOPA method relies on a truncated chain mapping that transform the initial Hamiltonian into","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"        hatH = fracomega_02 hatsigma_z +  c_0 frachatsigma_z2(hatb_0^dagger + hatb_0) + sum_i=0^N-1 t_i (hatb_i+1^dagger hatb_i + mathrmhc) + sum_i=0^N-1 epsilon_i hatb_i^dagger hatb_i","category":"page"},{"location":"examples/puredephasing/#The-code","page":"Pure-Dephasing","title":"The code","text":"","category":"section"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"First, we load the MPSdynamics.jl package to be able to perform the simulation, the Plots.jl one to plot the results, the LaTeXStrings.jl one to be able to use LaTeX in the plots and eventually QuadGK.jl to perform the analytical integral calculations. A notation is introduced for +‚àû.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"using MPSDynamics, Plots, LaTeXStrings, QuadGK\n\nconst ‚àû  = Inf","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"We then define variables for the physical parameters of the simulation. Among these, two are convergence parameters:","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"d is the number of states we retain for the truncated harmonic oscillators representation of environmental modes\nN is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The value of Œ≤ determines whether the environment is thermalized or not. The example as it is is the zero-temperature case. For the finite-temperature case, 'Œ≤ = ‚àû' has be commented instead of the line above that precises a Œ≤ value.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#----------------------------\n# Physical parameters\n#----------------------------\n\nd = 10 # number of Fock states of the chain modes\n\nN = 30 # length of the chain\n\nŒ± = 0.01 # coupling strength\n\nœâ0 = 0.008 # TLS gap\n\ns = 1 # ohmicity\n\nœâc = 0.035 # Cut-off of the spectral density J(œâ)\n\n#Œ≤ = 100 # Thermalized environment\n\nŒ≤ = ‚àû # Case zero temperature T=0, Œ≤ ‚Üí ‚àû","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"The chain coefficient have then to be calculated. This part differs for the zero-temperature case and the thermalized bath. For Œ≤ = , the chain coeffficients can be calculated with the function MPSDynamics.chaincoeffs_ohmic whereas the function MPSDynamics.chaincoeffs_finiteT is used when T neq 0  textK:","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"if Œ≤ == ‚àû\n    cpars = chaincoeffs_ohmic(N, Œ±, s; œâc=œâc)  # chain parameters, i.e. on-site energies œµ_i, hopping energies t_i, and system-chain coupling c_0\nelse\n    cpars = chaincoeffs_finiteT(N, Œ≤; Œ±=Œ±, s=s, J=nothing, œâc=œâc, mc=4, mp=0, AB=nothing, iq=1, idelta=2, procedure=:Lanczos, Mmax=5000, save=false)  # chain parameters, i.e. on-site energies œµ_i, hopping energies t_i, and system-chain coupling c_0\n    #= #If cpars is stored in \"../ChainOhmT/ohmicT\" \n    curdir = @__DIR__\n    dir_chaincoeff = abspath(joinpath(curdir, \"../ChainOhmT/ohmicT\"))\n    cpars  = readchaincoeffs(\"$dir_chaincoeff/chaincoeffs.h5\",N,Œ±,s,Œ≤) # chain parameters, i.e. on-site energies œµ_i, hopping energies t_i, and system-chain coupling c_0\n    =#\nend","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"An option is provided if the coefficient are saved to be reused.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is mathcalO(dt^3). In this example we present two one-site implementation of TDVP that both preserves the unitarity of the evolution:","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"the regular one-site method with the keyword :TDVP1 where all the virtual bonds of the MPS have the same bond dimension D\nthe adaptive method with the keyword :DTDVP where the bond dimension is locally increased at each time step if the TDVP projection error crosses a threshold value","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Logically the constant bond dimension of the MPS for TDVP1 and the threshold of the projection error for DTDVP are their respective convergence parameter.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#-----------------------\n# Simulation parameters\n#-----------------------\n\ndt = 1.0 # time step\n\ntfinal = 300.0 # simulation time\n\nmethod = :TDVP1 # time-evolution method\n\n#method = :DTDVP # time-evolution method\n\nD = 2 # MPS bond dimension","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Using MPSDynamics.jl built-in methods we define the Pure Dephasing model MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the 'local state' of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#---------------------------\n# MPO and initial state MPS\n#---------------------------\n\nH = puredephasingmpo(ŒîE, d, N, cpars)\n\n# Initial electronic system in a superposition of 1 and 2\nœà = zeros(2)\nœà[1] = 1/sqrt(2)\nœà[2] = 1/sqrt(2)\n\nA = productstatemps(physdims(H), state=[œà, fill(unitcol(1,d), N)...]) # MPS representation of |œà>|Vacuum>","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"We then chose the observables that will be stored in the data and the MPSDynamics.runsim arguments. This example relies on the storage of the reduced density matrix (called reduceddensity in runsim).","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"\n#---------------------------\n# Definition of observables\n#---------------------------\n\nob1 = OneSiteObservable(\"sz\", sz, 1)\n\n\n#-------------\n# Simulation\n#------------\n\nA, dat = runsim(dt, tfinal, A, H, prec=1E-4;\n                name = \"pure dephasing model with temperature\",\n                method = method,\n                obs = [ob1],\n                convobs = [ob1],\n                params = @LogParams(ŒîE, N, d, Œ±, s),\n                convparams = D,\n                reduceddensity=true,\n                verbose = false,\n                save = true,\n                plot = true,\n                );","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"After having performed the dynamics, the analytical decoherence function is numerically calculated with the help of the quadgk function (from the QuadGK.jl package). It reads","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#----------\n# Analytical results at specified temperature \n# (see The Theory of Open Quantum System, H.-P. Breuer & F. Petruccione 2002, Chapter 4)\n#----------\n\nJohmic(œâ,s) = (2*Œ±*œâ^s)/(œâc^(s-1))\n\ntime_analytical = LinRange(0.0,tfinal,Int(tfinal))\n\nŒìohmic(t) = - quadgk(x -> Johmic(x,s)*(1 - cos(x*t))*coth(Œ≤*x/2)/x^2, 0, œâc)[1]\n\nDecoherence_ohmic(t) = 0.5*exp(Œìohmic(t))","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"Eventually, the stored reduced density matrix is compared against the analytical formula","category":"page"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"#-------------\n# Plots\n#------------\n\nœÅ12 = abs.(dat[\"data/Reduced œÅ\"][1,2,:])\n\nplot(time_analytical, t->Decoherence_ohmic(t), label=\"Analytics\", title=L\"Pure Dephasing, Ohmic $s=%$s$, $\\beta = %$Œ≤ ~\\mathrm{K}$\", linecolor=:black, xlabel=\"Time (arb. units)\", ylabel=L\"Coherence $|\\rho_{12}(t)|$\", linewidth=4, titlefontsize=16, legend=:best, legendfontsize=16, xguidefontsize=16, yguidefontsize=16, tickfontsize=10)\n\nplot!(dat[\"data/times\"], œÅ12, lw=4, ls=:dash, label=\"Numerics\")","category":"page"},{"location":"examples/puredephasing/#Bibliography","page":"Pure-Dephasing","title":"Bibliography","text":"","category":"section"},{"location":"examples/puredephasing/","page":"Pure-Dephasing","title":"Pure-Dephasing","text":"[breuer]: Breuer, H.;Petruccione, F. The Theory of Open Quantum Systems; Oxford University Press, 2002.","category":"page"},{"location":"methods/#List-of-all-methods","page":"Methods","title":"List of all methods","text":"","category":"section"},{"location":"methods/","page":"Methods","title":"Methods","text":"Modules = [MPSDynamics]","category":"page"},{"location":"methods/#MPSDynamics.OneSiteObservable-Tuple{Any, Any, Any}","page":"Methods","title":"MPSDynamics.OneSiteObservable","text":"OneSiteObservable(name,op,sites)\n\nComputes the local expectation value of the one-site operator op on the specified sites. Used to define one-site observables that are obs and convobs parameters for the runsim function.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.MPOtoVector-Tuple{ITensors.MPO}","page":"Methods","title":"MPSDynamics.MPOtoVector","text":"MPOtoVector(mpo::MPO)\n\nConvert an ITensors chain MPO into a form compatible with MPSDynamics\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.addchild!-Tuple{MPSDynamics.Tree, Int64}","page":"Methods","title":"MPSDynamics.addchild!","text":"addchild!(tree::Tree, id::Int)\n\nAdd child to node id of tree.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.addchildren!-Tuple{MPSDynamics.Tree, Int64, Int64}","page":"Methods","title":"MPSDynamics.addchildren!","text":"addchildren!(tree::Tree, id::Int, n::Int)\n\nAdd n children to node id of tree.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chaincoeffs_ohmic-Tuple{Any, Any, Any}","page":"Methods","title":"MPSDynamics.chaincoeffs_ohmic","text":"chaincoeffs_ohmic(N, Œ±, s; œâc=1, soft=false)\n\nGenerate chain coefficients œµ_0œµ_1t_0t_1c_0 for an Harmonic bath at zero temperature with a power law spectral density given by:\n\nsoft cutoff: J(œâ) = 2œÄŒ±œâ_c (fracœâœâ_c)^s exp(-œâœâ_c) \n\nhard cutoff: J(œâ) = 2œÄŒ±œâ_c (fracœâœâ_c)^s Œ∏(œâ-œâ_c)\n\nThe coefficients parameterise the chain Hamiltonian\n\nH = H_S + c_0 A_SB_0+sum_i=0^N-1t_i (b_i+1^dagger b_i +hc) + sum_i=0^N œµ_ib_i^dagger b_i\n\nwhich is unitarily equivalent (before the truncation to N sites) to\n\nH = H_S + A_Sint_0^dœâsqrtfracJ(œâ)œÄB_œâ + int_0^dœâœâb_œâ^dagger b_œâ\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chainmps-Tuple{Int64, Int64, Int64}","page":"Methods","title":"MPSDynamics.chainmps","text":"chainmps(N::Int, site::Int, numex::Int)\n\nGenerate an MPS with numex excitations on site\n\nThe returned MPS will have bond-dimensions and physical dimensions numex+1\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chainmps-Tuple{Int64, Vector{Int64}, Int64}","page":"Methods","title":"MPSDynamics.chainmps","text":"chainmps(N::Int, sites::Vector{Int}, numex::Int)\n\nGenerate an MPS with numex excitations of an equal super-position over sites\n\nThe returned MPS will have bond-dimensions and physical dimensions numex+1\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.chainprop-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.chainprop","text":"chainprop(t, cparams...)\n\nPropagate an excitation placed initially on the first site of a tight-binding chain with parameters given by cparams for a time t and return occupation expectation for each site.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.dynamap-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.dynamap","text":"dynamap(ps1,ps2,ps3,ps4)\n\nCalulate complete dynamical map to time step at which ps1, ps2, ps3 and ps4 are specified.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.electron2kmps","page":"Methods","title":"MPSDynamics.electron2kmps","text":"electronkmps(N::Int, k::Vector{Int}, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS with 2 electrons in k-states k1 and k2.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.electronkmps","page":"Methods","title":"MPSDynamics.electronkmps","text":"electronkmps(N::Int, k::Int, spin=:Up, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS for an electron with momentum k.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.elementmpo-Tuple{Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.elementmpo","text":"elementmpo(M, el...)\n\nReturn the element of the MPO M for the set of physical states el...\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.elementmps-Tuple{Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.elementmps","text":"elementmps(A, el...)\n\nReturn the element of the MPS A for the set of physical states el...\n\nExamples\n\njulia> A = chainmps(6, [2,4], 1);\n\njulia> elementmps(A, 1, 2, 1, 1, 1, 1)\n0.7071067811865475\n\njulia> elementmps(A, 1, 1, 1, 2, 1, 1)\n0.7071067811865475\n\njulia> elementmps(A, 1, 2, 1, 2, 1, 1)\n0.0\n\njulia> elementmps(A, 1, 1, 1, 1, 1, 1)\n0.0\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.entanglemententropy-Tuple{Any}","page":"Methods","title":"MPSDynamics.entanglemententropy","text":"entanglemententropy(A)\n\nFor a list of tensors A representing a right orthonormalized MPS, compute the entanglement entropy for a bipartite cut for every bond.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.findchainlength-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.findchainlength","text":"findchainlength(T, cparams...; eps=10^-6)\n\nEstimate length of chain required for a particular set of chain parameters by calculating how long an excitation on the first site takes to reach the end. The chain length is given as the length required for the excitation to have just reached the last site after time T. The initial number of sites in cparams has to be larger than the findchainlength result.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.findchild-Tuple{MPSDynamics.TreeNode, Int64}","page":"Methods","title":"MPSDynamics.findchild","text":"findchild(node::TreeNode, id::Int)\n\nReturn integer corresponding to the which number child site id is of node.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.hbathchain-Tuple{Int64, Int64, Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.hbathchain","text":"hbathchain(N::Int, d::Int, chainparams, longrangecc...; tree=false, reverse=false, coupletox=false)\n\nGenerate MPO representing a tight-binding chain of N oscillators with d Fock states each. Chain parameters are supplied in the standard form: chainparams =œµ_0œµ_1t_0t_1c_0. The output does not itself represent a complete MPO but will possess an end which is open and should be attached to another tensor site, usually representing the system.\n\nArguments\n\nreverse: If reverse=true create a chain were the last (i.e. Nth) site is the site which couples to the system\ncoupletox: Used to choose the form of the system coupling. coupletox=true gives a non-number conserving coupling of the form H_textI= A_textS(b_0^dagger + b_0) where A_textS is a system operator, while coupletox=false gives the number-converving coupling H_textI=(A_textS b_0^dagger + A_textS^dagger b_0)\ntree: If true the resulting chain will be of type TreeNetwork; useful for construcing tree-MPOs \n\nExample\n\nOne can constuct a system site tensor to couple to a chain by using the function up to populate the tensor. For example, to construct a system site with Hamiltonian Hs and coupling operator As, the system tensor M is constructed as follows for a non-number conserving interaction:\n\nu = one(Hs) # system identity\nM = zeros(1,3,2,2)\nM[1, :, :, :] = up(Hs, As, u)\n\nThe full MPO can then be constructed with:\n\nHmpo = [M, hbathchain(N, d, chainparams, coupletox=true)...]\n\nSimilarly for a number conserving interaction the site tensor would look like:\n\nu = one(Hs) # system identity\nM = zeros(1,4,2,2)\nM[1, :, :, :] = up(Hs, As, As', u)\n\nAnd the full MPO would be\n\nHmpo = [M, hbathchain(N, d, chainparams; coupletox=false)...]\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.heisenbergmpo","page":"Methods","title":"MPSDynamics.heisenbergmpo","text":"heisenbergmpo(N::Int, J=1.0) = xyzmpo(N; Jx=J)\n\nGenerate MPO for the N-spin Heisenberg XXX model, defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J œÉ_x^n œÉ_x^n+1 - J œÉ_y^n œÉ_y^n+1 - J œÉ_z^n œÉ_z^n+1\n\nwith œÉ_x^n œÉ_y^n œÉ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.ibmmpo-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.ibmmpo","text":"ibmmpo(œâ0, d, N, chainparams; tree=false)\n\nGenerate MPO for a spin-1/2 coupled to a chain of harmonic oscillators with the interacting boson model (IBM), defined by the Hamiltonian\n\nH = fracœâ_02œÉ_z +  c_0œÉ_z(b_0^dagger+b_0) + sum_i=0^N-1 t_i (b_i+1^dagger b_i +hc) + sum_i=0^N œµ_ib_i^dagger b_i.\n\nThe spin is on site 1 of the MPS and the bath modes are to the right.\n\nThis Hamiltonain is unitarily equivalent (before the truncation to N sites) to the spin-boson Hamiltonian defined by\n\nH =  fracœâ_02œÉ_z + œÉ_zint_0^ dœâsqrtfracJ(œâ)œÄ(b_œâ^dagger+b_œâ) + int_0^ dœâ œâb_œâ^dagger b_œâ.\n\nThe chain parameters, supplied by chainparams=œµ_0œµ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(œâ) at any temperature.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.isingmpo-Tuple{Int64}","page":"Methods","title":"MPSDynamics.isingmpo","text":"isingmpo(N; J=1.0, h=1.0)\n\nGenerate MPO for the N-spin 1D Ising model with external field vech = (00h), defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J_x œÉ_x^n œÉ_x^n+1 + sum_n=1^N(- h_z œÉ_z^n)\n\nwith œÉ_x^n œÉ_y^n œÉ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.longrange_isingmpo","page":"Methods","title":"MPSDynamics.longrange_isingmpo","text":"longrange_isingmpo(N::Int, Œ±::Float64=0.; J=1.0, h=1.0) = longrange_xyzmpo(N, Œ±; Jx=J, Jy=0., Jz=0., hz=h, hx=0.)\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.longrange_xyzmpo","page":"Methods","title":"MPSDynamics.longrange_xyzmpo","text":"longrange_xyzmpo(N::Int, Œ±::Float64=0.; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)\n\nGennerate MPO for the N-spin long-range XYZ model with external field vech=(h_x 0 h_z), , defined by the Hamiltonian\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.measure-Tuple{Any, OneSiteObservable}","page":"Methods","title":"MPSDynamics.measure","text":"measure(A, O; kwargs...)\n\nMeasure observable O on mps state A\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.measure1siteoperator-Tuple{Vector, Any, Vector{Int64}}","page":"Methods","title":"MPSDynamics.measure1siteoperator","text":"measure1siteoperator(A::Vector, O, sites::Vector{Int})\n\nFor a list of tensors A representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site or just one if it is specified.\n\nFor calculating operators on single sites this will be more efficient if the site is on the left of the mps.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.measure1siteoperator-Tuple{Vector, Any}","page":"Methods","title":"MPSDynamics.measure1siteoperator","text":"measure1siteoperator(A::Vector, O)\n\nFor a list of tensors A representing a right orthonormalized MPS, compute the local expectation value of a one-site operator O for every site.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.measure2siteoperator-Tuple{Vector, Any, Any, Int64, Int64}","page":"Methods","title":"MPSDynamics.measure2siteoperator","text":" measure2siteoperator(A::Vector, M1, M2, j1, j2)\n\nCaculate expectation of M1*M2 where M1 acts on site j1 and M2 acts on site j2, assumes A is right normalised.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.modemps","page":"Methods","title":"MPSDynamics.modemps","text":"modemps(N::Int, k::Vector{Int}, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS with numex excitations of an equal superposition of modes k of a bosonic tight-binding chain.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.modemps-2","page":"Methods","title":"MPSDynamics.modemps","text":"modemps(N::Int, k::Int, numex::Int, chainparams=[fill(1.0,N), fill(1.0,N-1)])\n\nGenerate an MPS with numex excitations of mode k of a bosonic tight-binding chain. \n\nchainparams takes the form [e::Vector, t::Vector] where e are the on-site energies and t are the hoppping parameters.\n\nThe returned MPS will have bond-dimensions and physical dimensions numex+1\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.mpsembed!-Tuple{Vector, Int64}","page":"Methods","title":"MPSDynamics.mpsembed!","text":"mpsembed(A::Vector, Dmax::Int)\n\nEmbed MPS A in manifold of max bond-dimension Dmax\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsleftnorm!","page":"Methods","title":"MPSDynamics.mpsleftnorm!","text":"mpsleftnorm!(A::Vector, jq::Int=length(A))\n\nLeft orthoganalise MPS A up to site jq.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.mpsmixednorm!-Tuple{MPSDynamics.TreeNetwork, Int64}","page":"Methods","title":"MPSDynamics.mpsmixednorm!","text":"mpsmixednorm!(A::TreeNetwork, id::Int)\n\nNormalise tree-MPS A such that orthogonality centre is on site id.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsmixednorm!-Tuple{Vector, Int64}","page":"Methods","title":"MPSDynamics.mpsmixednorm!","text":"mpsmixednorm!(A::Vector, OC::Int)\n\nPut MPS A into mixed canonical form with orthogonality centre on site OC.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsmoveoc!-Tuple{MPSDynamics.TreeNetwork, Int64}","page":"Methods","title":"MPSDynamics.mpsmoveoc!","text":"mpsmoveoc!(A::TreeNetwork, id::Int)\n\nMove the orthogonality centre of right normalised tree-MPS A to site id.\n\nThis function will be more efficient than using mpsmixednorm! if the tree-MPS is already right-normalised.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsrightnorm!","page":"Methods","title":"MPSDynamics.mpsrightnorm!","text":"mpsrightnorm!(A::Vector, jq::Int=1)\n\nRight orthoganalise MPS A up to site jq.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.mpsrightnorm!-Tuple{MPSDynamics.TreeNetwork}","page":"Methods","title":"MPSDynamics.mpsrightnorm!","text":"mpsrightnorm!(A::TreeNetwork)\n\nWhen applied to a tree-MPS, right normalise towards head-node.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.mpsshiftoc!-Tuple{MPSDynamics.TreeNetwork, Int64}","page":"Methods","title":"MPSDynamics.mpsshiftoc!","text":"mpsshiftoc!(A::TreeNetwork, newhd::Int)\n\nShift the orthogonality centre by one site, setting new head-node newhd.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.multiply-Tuple{Vector, Vector}","page":"Methods","title":"MPSDynamics.multiply","text":"multiply(M1::Vector, M2::Vector)\n\nCalculates M1*M2 where M1 and M2 are MPOs\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.nearestneighbourmpo","page":"Methods","title":"MPSDynamics.nearestneighbourmpo","text":"nearestneighbourmpo(N::Int, h0, A, Ad = A')\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.nearestneighbourmpo-2","page":"Methods","title":"MPSDynamics.nearestneighbourmpo","text":"nearestneighbourmpo(tree_::Tree, h0, A, Ad = A')\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.normmps-Tuple{MPSDynamics.TreeNetwork}","page":"Methods","title":"MPSDynamics.normmps","text":"normmps(net::TreeNetwork; mpsorthog=:None)\n\nWhen applied to a tree-MPS mpsorthog=:Left is not defined.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.normmps-Tuple{Vector}","page":"Methods","title":"MPSDynamics.normmps","text":"normmps(A::Vector; mpsorthog=:None)\n\nCalculate norm of MPS A.\n\nSetting mpsorthog=:Right/:Left will calculate the norm assuming right/left canonical form. Setting mpsorthog=OC::Int will cause the norm to be calculated assuming the orthoganility center is on site OC. If mpsorthog is :None the norm will be calculated as an MPS-MPS product.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.orthcentersmps-Tuple{Vector}","page":"Methods","title":"MPSDynamics.orthcentersmps","text":"orthcentersmps(A)\n\nCompute the orthoganality centres of MPS A.\n\nReturn value is a list in which each element is the corresponding site tensor of A with the orthoganility centre on that site. Assumes A is right normalised.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.physdims-Tuple{Vector}","page":"Methods","title":"MPSDynamics.physdims","text":"physdims(M)\n\nReturn the physical dimensions of an MPS or MPO M.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.productstatemps","page":"Methods","title":"MPSDynamics.productstatemps","text":"productstatemps(physdims::Dims, Dmax=1; state=:Vacuum, mpsorthog=:Right)\n\nReturn an MPS representing a product state with local Hilbert space dimensions given by physdims.\n\nBy default all bond-dimensions will be 1 since the state is a product state. However, to embed the product state in a manifold of greater bond-dimension, Dmax can be set accordingly.\n\nThe indvidual states of the MPS sites can be provided by setting state to a list of column vectors. Setting state=:Vacuum will produce an MPS in the vacuum state (where the state of each site is represented by a column vector with a 1 in the first row and zeros elsewhere). Setting state=:FullOccupy will produce an MPS in which each site is fully occupied (ie. a column vector with a 1 in the last row and zeros elsewhere).\n\nThe argument mpsorthog can be used to set the gauge of the resulting MPS.\n\nExample\n\njulia> œà = unitcol(1,2); d = 6; N = 30; Œ± = 0.1; Œî = 0.0; œâ0 = 0.2; s = 1\n\njulia> cpars = chaincoeffs_ohmic(N, Œ±, s)\n\njulia> H = spinbosonmpo(œâ0, Œî, d, N, cpars)\n\njulia> A = productstatemps(physdims(H), state=[œà, fill(unitcol(1,d), N)...]) # MPS representation of |œà>|Vacuum>\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.productstatemps-2","page":"Methods","title":"MPSDynamics.productstatemps","text":"productstatemps(N::Int, d::Int, Dmax=1; state=:Vacuum, mpsorthog=:Right)\n\nReturn an N-site MPS with all local Hilbert space dimensions given by d. \n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.randisometry-Tuple{Type, Int64, Int64}","page":"Methods","title":"MPSDynamics.randisometry","text":"randisometry([T=Float64], dims...)\n\nConstruct a random isometry\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.randmps","page":"Methods","title":"MPSDynamics.randmps","text":"randmps(N::Int, d::Int, Dmax::Int, T=Float64)\n\nConstruct a random, N-site, right-normalised MPS with all local Hilbert space dimensions given by d.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.randmps-2","page":"Methods","title":"MPSDynamics.randmps","text":"randmps(tree::Tree, physdims, Dmax::Int, T::Type{<:Number} = Float64)\n\nConstruct a random, right-normalised, tree-MPS, with structure given by tree and max bond-dimension given by Dmax.\n\nThe local Hilbert space dimensions are specified by physdims which can either be of type Dims{length(tree)}, specifying the dimension of each site, or of type Int, in which case the same local dimension is used for every site.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.randmps-Union{Tuple{N}, Tuple{Tuple{Vararg{Int64, N}}, Int64}, Tuple{Tuple{Vararg{Int64, N}}, Int64, Type{<:Number}}} where N","page":"Methods","title":"MPSDynamics.randmps","text":"randmps(physdims::Dims{N}, Dmax::Int, T::Type{<:Number} = Float64) where {N}\n\nConstruct a random, right-normalised MPS with local Hilbert space dimensions given by physdims and max bond-dimension given by Dmax. \n\nT specifies the element type, eg. use T=ComplexF64 for a complex valued MPS.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.randtree-Tuple{Int64, Int64}","page":"Methods","title":"MPSDynamics.randtree","text":"randtree(numnodes::Int, maxdegree::Int)\n\nConstruct a random tree with nummodes modes and max degree maxdegree.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.readchaincoeffs-Tuple{Any, Vararg{Any}}","page":"Methods","title":"MPSDynamics.readchaincoeffs","text":"readchaincoeffs(fdir, params...)\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.rmsd-Tuple{Any, Any}","page":"Methods","title":"MPSDynamics.rmsd","text":"rmsd(dat1::Vector{Float64}, dat2::Vector{Float64})\n\nCalculate the root mean squared difference between two measurements of an observable over the same time period.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.spinbosonmpo-NTuple{5, Any}","page":"Methods","title":"MPSDynamics.spinbosonmpo","text":"spinbosonmpo(œâ0, Œî, d, N, chainparams; rwa=false, tree=false)\n\nGenerate MPO for a spin-1/2 coupled to a chain of harmonic oscillators, defined by the Hamiltonian\n\nH = fracœâ_02œÉ_z + ŒîœÉ_x + c_0œÉ_x(b_0^dagger+b_0) + sum_i=0^N-1 t_i (b_i+1^dagger b_i +hc) + sum_i=0^N œµ_ib_i^dagger b_i.\n\nThe spin is on site 1 of the MPS and the bath modes are to the right.\n\nThis Hamiltonain is unitarily equivalent (before the truncation to N sites) to the spin-boson Hamiltonian defined by\n\nH =  fracœâ_02œÉ_z + ŒîœÉ_x + œÉ_xint_0^ dœâsqrtfracJ(œâ)œÄ(b_œâ^dagger+b_œâ) + int_0^ dœâ œâb_œâ^dagger b_œâ.\n\nThe chain parameters, supplied by chainparams=œµ_0œµ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(œâ) at any temperature.\n\nThe rotating wave approximation can be made by setting rwa=true.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.spinchainmpo-Tuple{Int64}","page":"Methods","title":"MPSDynamics.spinchainmpo","text":"spinchainmpo(N::Int; J=1.0, hz=1.0, hx=0.0, i=div(N,2))\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.svdmps-Tuple{Any}","page":"Methods","title":"MPSDynamics.svdmps","text":"svdmps(A)\n\nFor a right normalised mps A compute the full svd spectrum for a bipartition at every bond.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.svdtrunc-Tuple{Any}","page":"Methods","title":"MPSDynamics.svdtrunc","text":"U, S, Vd = svdtrunc(A; truncdim = max(size(A)...), truncerr = 0.)\n\nPerform a truncated SVD, with maximum number of singular values to keep equal to truncdim or truncating any singular values smaller than truncerr. If both options are provided, the smallest number of singular values will be kept. Unlike the SVD in Julia, this returns matrix U, a diagonal matrix (not a vector) S, and Vt such that A ‚âà U * S * Vt\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.tightbinding_mpo-NTuple{4, Any}","page":"Methods","title":"MPSDynamics.tightbinding_mpo","text":"tightbinding_mpo(N, œµd, chainparams1, chainparams2)\n\nGenerate MPO for a tight-binding chain of N fermionic sites with a single impurity site (fermionic as well) \nof energy œµd at the center. The impurity is coupled to two leads, each described by a set of chain parameters.\nThe interactions are nearest-neighbour, with the first N/2-1 sites corresponding to the first lead,\nthe Nth site corresponding to the impurity, and the rest of the sites corresponding to the second\nlead.\n\n# Arguments\n\n* `N::Int`: number of sites in the chain\n* `œµd::Real`: energy of the impurity site at the center, as Ed - Œº, where Œº is the chemical potential\n* chainparams1::Array{Real,1}: chain parameters for the first lead\n* chainparams2::Array{Real,1}: chain parameters for the second lead\n\nThe chain parameters are given in the standard form: `chainparams` ``=[[œµ_0,œµ_1,...],[t_0,t_1,...],c_0]``.\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.tightbindingmpo-Tuple{Int64, Int64}","page":"Methods","title":"MPSDynamics.tightbindingmpo","text":"tightbindingmpo(N::Int, d::Int; J=1.0, e=1.0)\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.tunnelingmpo-Tuple{Any, Any, Any, Any, Any, Int64, Int64}","page":"Methods","title":"MPSDynamics.tunnelingmpo","text":"tunnelingmpo(œµ, delta, Œ±, s, Œ≤, d::Int, nummodes::Int; tree=false, œâc=1)\n\n\n\n\n\n","category":"method"},{"location":"methods/#MPSDynamics.twobathspinmpo","page":"Methods","title":"MPSDynamics.twobathspinmpo","text":"twobathspinmpo(œâ0, Œî, Nl, Nr, dl, dr, chainparamsl=[fill(1.0,N),fill(1.0,N-1), 1.0], chainparamsr=chainparamsl; tree=false)\n\nGenerate MPO for a spin-1/2 coupled to two chains of harmonic oscillators, defined by the Hamiltonian\n\nH = fracœâ_02œÉ_z + ŒîœÉ_x + c_0^rœÉ_x(b_0^dagger+b_0) + sum_i=0^N_r-1 t_i^r (b_i+1^dagger b_i +hc) + sum_i=0^N_r œµ_i^rb_i^dagger b_i + c_0^lœÉ_x(d_0^dagger+d_0) + sum_i=0^N_l-1 t_i^l (d_i+1^dagger d_i +hc) + sum_i=0^N_l œµ_i^l d_i^dagger d_i.\n\nThe spin is on site N_l + 1 of the MPS, surrounded by the left chain modes and the right chain modes.\n\nThis Hamiltonain is unitarily equivalent (before the truncation to N sites) to the spin-boson Hamiltonian defined by\n\nH =  fracœâ_02œÉ_z + ŒîœÉ_x + œÉ_xint_0^ dœâsqrtfracJ(œâ)œÄ(b_œâ^dagger+b_œâ) + int_0^ dœâ œâb_œâ^dagger b_œâi + œÉ_xint_0^ dœâsqrtfracJ^l(œâ)œÄ(d_œâ^dagger+d_œâ) + int_0^ dœâ œâd_œâ^dagger d_œâ.\n\nThe chain parameters, supplied by chainparams=œµ_0œµ_1t_0t_1c_0, can be chosen to represent any arbitrary spectral density J(œâ) at any temperature. The two chains can have a different spectral density.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.xxzmpo","page":"Methods","title":"MPSDynamics.xxzmpo","text":"xxzmpo(N::Int, Œî = 1.0, J=1.0) = xyzmpo(N; Jx=J, Jy=J, Jz=J*Œî)\n\nGenerate MPO for the N-spin XXZ model, defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J œÉ_x^n œÉ_x^n+1 - J œÉ_y^n œÉ_y^n+1 - Delta J œÉ_z^n œÉ_z^n+1\n\nwith œÉ_x^n œÉ_y^n œÉ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"function"},{"location":"methods/#MPSDynamics.xyzmpo-Tuple{Int64}","page":"Methods","title":"MPSDynamics.xyzmpo","text":"xyzmpo(N::Int; Jx=1.0, Jy=Jx, Jz=Jx, hx=0., hz=0.)\n\nGenerate MPO for the N-spin XYZ model with external field vech=(h_x 0 h_z), , defined by the Hamiltonian\n\nH = sum_n=1^N-1 -J_x œÉ_x^n œÉ_x^n+1 - J_y œÉ_y^n œÉ_y^n+1 - J_z œÉ_z^n œÉ_z^n+1 + sum_n=1^N(- h_x œÉ_x^n - h_z œÉ_z^n)\n\nwith œÉ_x^n œÉ_y^n œÉ_z^n the Pauli spin-1/2 matrices of the n^textth site.\n\n\n\n\n\n","category":"method"},{"location":"examples/sbm/#The-Spin-Boson-Model","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"","category":"section"},{"location":"examples/sbm/#Context","page":"The Spin-Boson Model","title":"Context","text":"","category":"section"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"The Spin-Boson Model (SBM) is a prototypical model in the theory of open quantum systems where a two level system interacts linearly with a bosonic bath","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"\thatH = fracomega_02hatsigma_z + Deltahatsigma_x + int_0^+inftyomega hata^dagger_omegahata_omega mathrmdomega + hatsigma_xint_0^+inftysqrtJ(omega)(hata_omega + hata^dagger_omega)mathrmdomega","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Even though this model is fairly simple it is physically very rich and it is not analytically solvable. For these reason it has become a test-bed for numerical methods simulating open quantum systems dynamics in the non-perturbative non-Markovian regime.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"For instance when the SD is Ohmic, this model presents a phase transition between a so called localised and a delocalised phase for alpha approx 12.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Here we break out and comment the script in MPSDynamics/examples/sbm_zero_temperature.jl to show how to simulate this model with an Ohmic SD (hard cut-off) using the T-TEDOPA method as implemented in MPSDynamics.jl.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"The T-TEDOPA method relies on a truncated chain mapping that transform the initial Hamiltonian into","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"\thatH = fracomega_02 hatsigma_z + Delta hatsigma_x + c_0 hatsigma_x(hatb_0^dagger + hatb_0) + sum_i=0^N-1 t_i (hatb_i+1^dagger hatb_i + mathrmhc) + sum_i=0^N-1 epsilon_i hatb_i^dagger hatb_i ","category":"page"},{"location":"examples/sbm/#The-code","page":"The Spin-Boson Model","title":"The code","text":"","category":"section"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"First a multi-line comment introduces the model and the aim of the script.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#=\n    Example of a zero-temperature Spin-Boson Model with an hard cut-off Ohmic spectral density J(œâ) = 2Œ±œâ when œâ < œâc and 0 otherwise\n\n    The dynamics is simulated using the T-TEDOPA method that maps the normal modes environment into a non-uniform tight-binding chain.\n\n    H = \\\\frac{œâ_0}{2} œÉ_z + Œî œÉ_x + c_0 œÉ_x(b_0^\\\\dagger + b_0) + \\\\sum_{i=0}^{N-1} t_i (b_{i+1}^\\\\dagger b_i +h.c.) + \\\\sum_{i=0}^{N-1} œµ_i b_i^\\\\dagger b_i \n\n    Two variants of the one-site Time Dependent Variational Principal (TDVP) are presented for the time evolution of the quantum state.\n=#","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We load the MPSdynamics.jl package to be able to perform the simulation, the Plots.jl one to plot the results, and the LaTeXStrings.jl one to be able to use LaTeX in the plots.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"using MPSDynamics, Plots, LaTeXStrings","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We then define variables for the physical parameters of the simulation. Among these, two are convergence parameters:","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"d is the number of states we retain for the truncated harmonic oscillators representation of environmental modes \nN is the number of chain (environmental) modes we keep. This parameters determines the maximum simulation time of the simulation: indeed excitations that arrive at the end of the chain are reflected towards the system and can lead to unphysical results","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#----------------------------\n# Physical parameters\n#----------------------------\n\nd = 6 # number of Fock states of the chain modes\n\nN = 30 # length of the chain\n\nŒ± = 0.1 # coupling strength\n\nŒî = 0.0 # tunneling \n\nœâ0 = 0.2 # TLS gap\n\ns = 1 # ohmicity\n\ncpars = chaincoeffs_ohmic(N, Œ±, s) # chain parameters, i.e. on-site energies œµ_i, hopping energies t_i, and system-chain coupling c_0","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"We set the simulation parameters and choose a time evolution method. As always for simulations of dynamics, the time step must be chosen wisely. The error of the TDVP methods is mathcalO(dt^3). In this example we present two one-site implementation of TDVP that both preserves the unitarity of the evolution:","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"the regular one-site method with the keyword :TDVP1 where all the virtual bonds of the MPS have the same bond dimension D\nthe adaptive method with the keyword :DTDVP where the bond dimension is locally increased at each time step if the TDVP projection error crosses a threshold value","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Logically the constant bond dimension of the MPS for TDVP1 and the threshold of the projection error for DTDVP are their respective convergence parameter. ","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#-----------------------\n# Simulation parameters\n#-----------------------\n\ndt = 0.5 # time step\n\ntfinal = 30.0 # simulation time\n\nmethod = :TDVP1 # Regular one-site TDVP (fixed bond dimension)\n\n# method = :DTDVP # Adaptive one-site TDVP (dynamically updating bond dimension)\n\nconvparams = [2,4,6] # MPS bond dimension (1TDVP)\n\n# convparams = [1e-2, 1e-3, 1e-4] # threshold value of the projection error (DTDVP)","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"Using MPSDynamics.jl built-in methods we define the SBM MPO and the MPS representing the initial state. This initial state is a product state between the system and the chain. It is constructed using a list of the 'local state' of each site of the MPS, and the dimensions of the physical legs of the MPS are set to be the same as the ones of the MPO.","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#---------------------------\n# MPO and initial state MPS\n#---------------------------\n\nH = spinbosonmpo(œâ0, Œî, d, N, cpars) # MPO representation of the Hamiltonian\n\nœà = unitcol(1,2) # Initial up-z system state \n\nA = productstatemps(physdims(H), state=[œà, fill(unitcol(1,d), N)...]) # MPS representation of |œà>|Vacuum>","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#---------------------------\n# Definition of observables\n#---------------------------\n\nob1 = OneSiteObservable(\"sz\", sz, 1)\n\nob2 = OneSiteObservable(\"chain mode occupation\", numb(d), (2,N+1))\n\nob3 = TwoSiteObservable(\"SXdisp\", sx, disp(d), [1], collect(2:N+1))","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#-------------\n# Simulation\n#------------\n\nA, dat = runsim(dt, tfinal, A, H;\n                name = \"ohmic spin boson model\",\n                method = method,\n                obs = [ob2,ob3],\n                convobs = [ob1],\n                params = @LogParams(N, d, Œ±, Œî, œâ0, s),\n                convparams = convparams,\n                verbose = false,\n                savebonddims = true, # this keyword argument enables the bond dimension at each time step to be saved when using DTDVP\n                save = true,\n                plot = true,\n                );","category":"page"},{"location":"examples/sbm/","page":"The Spin-Boson Model","title":"The Spin-Boson Model","text":"#----------\n# Plots\n#----------\n\nmethod == :TDVP1 && plot(dat[\"data/times\"], dat[\"convdata/sz\"], label=[\"Dmax = 2\" \"Dmax = 4\" \"Dmax = 6\"], xlabel=L\"t\",ylabel=L\"\\sigma_z\")\n\nmethod == :DTDVP && plot(dat[\"data/times\"], dat[\"convdata/sz\"], label=[\"p = 1e-2\" \"p = 1e-3\" \"p = 1e-4\"], xlabel=L\"t\",ylabel=L\"\\sigma_z\") \n\nmethod == :DTDVP && heatmap(dat[\"data/times\"], collect(0:N+1), dat[\"data/bonddims\"], xlabel=L\"t\",ylabel=\"bond index\")\n\nheatmap(dat[\"data/times\"], collect(1:N), abs.(dat[\"data/SXdisp\"][1,:,:]), xlabel=L\"t\",ylabel=\"chain mode\")","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The MPSDynamics.jl package provides an easy to use interface for performing tensor network simulations on matrix product states (MPS) and tree tensor network (TTN) states. Written in the Julia programming language, MPSDynamics.jl is a versatile open-source package providing a choice of several variants of the Time-Dependent Variational Principle (TDVP) method for time evolution.  The package also provides strong support for the measurement of observables, as well as the storing and logging of data, which makes it a useful tool for the study of many-body physics.  The package has been developed with the aim of studying non-Markovian open system dynamics at finite temperature using the state-of-the-art numerically exact Thermalized-Time Evolving Density operator with Orthonormal Polynomials Algorithm (T-TEDOPA) based on environment chain mapping. However the methods implemented can equally be applied to other areas of physics.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe documentation is currently undergoing massive restructurations/improvement. It's a work in progress until the next release scheduled for May, 2024.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The package may be installed by typing the following into a Julia REPL","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    ] add https://github.com/shareloqs/MPSDynamics.git","category":"page"},{"location":"#Table-of-Contents","page":"Introduction","title":"Table of Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"index.md\", \"user-guide.md\", \"./examples/sbm.md\", \"./examples/puredephasing.md\", \"theory.md\", \"methods.md\", \"dev.md\"]\nDepth = 3","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"If you use the package in your research, please consider citing it. You can add the Zenodo record to your BibTex file:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@misc{mpsdynamics_zenodo2021,\n\ttitle = {shareloqs/{MPSDynamics}},\n\tshorttitle = {{MPSDynamics.jl}},\n\turl = {https://zenodo.org/record/5106435},\n\tabstract = {Tensor network simulations for finite temperature, open quantum system dynamics},\n\tpublisher = {Zenodo},\n\tauthor = {Dunnett, Angus and Lacroix, Thibaut and Le D√©, Brieuc and Riva, Angela},\n\tyear = {2021},\n\tdoi = {10.5281/zenodo.5106435},\n}","category":"page"}]
}
